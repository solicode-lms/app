<!-- ===== 6.1.CrÃ©ation nouvelle tÃ¢che pour l'agent .md ===== -->

#### CrÃ©ation nouvelle tÃ¢che pour l'agent 

ModÃ¨le de prompt 

````md
### ğŸ§© TÃ¢che : [Nom clair et explicite de la tÃ¢che]

#### ğŸ¯ Objectif fonctionnel

#### ğŸ“ Contexte technique

#### ğŸ› ï¸ Action(s) attendue(s)
[Liste claire et structurÃ©e des actions Ã  effectuer]

- [x] Ajouter un champ `xxx` dans la table `yyy` (via migration).
- [x] Mettre Ã  jour la classe `Service` pour inclure la mÃ©thode `getXxx()`.
- [x] Modifier la vue `index.blade.php` pour afficher la nouvelle colonne.

````

<!-- ===== 6.2.Base de donnÃ©es.md ===== -->

#### Modification de la base de donnÃ©es

- **RÃ¨gle globale :**  
  - Toute table **nouvellement crÃ©Ã©e** doit contenir une colonne `reference` (type string) avec la contrainte `unique`.  
  - Si lâ€™on ajoute des colonnes Ã  une table existante, la colonne `reference` nâ€™est pas requise (elle existe dÃ©jÃ ).

- **OpÃ©rations autorisÃ©es :**  
  1. **CrÃ©er une nouvelle table**  
  2. **Ajouter une colonne** Ã  une table existante  

- **DÃ©tection automatique du module :**  
  1. **PrÃ©sentation du besoin :**  
     - Lorsque lâ€™utilisateur demande simplement â€œCrÃ©er la table `NomDeLaTable`â€, lâ€™agent doit :  
       - Analyser le nom de la table (`NomDeLaTable`).  
       - Chercher, dans sa connaissance des modules existants, celui qui est le plus cohÃ©rent avec cette table (par exemple :  
         - Les tables liÃ©es aux Â« projets Â» et Â« rÃ©alisations de projets Â» doivent aller dans `PkgGestionTaches`.  
         - Les tables liÃ©es aux entitÃ©s gÃ©nÃ©riques (utilisateurs, rÃ´les, paramÃ¨tres systÃ¨meâ€¦) vont dans `Core`.  
         - Les tables dâ€™associations ou de cotisations vont dans `PkgGestionAssociation`.  
         - Etc.)  
       - Si un mapping est trouvÃ© sans ambiguÃ¯tÃ©, dÃ©duire automatiquement `<NomDuModule>`.  
       - Sinon (aucune correspondance claire ou plusieurs modules potentiels), poser une question de validation :
         > Â« Je n'arrive pas Ã  dÃ©terminer dans quel module placer la table `NomDeLaTable`. Dans quel module souhaitez-vous la crÃ©er ? (par ex. : Core, PkgGestionTaches, PkgGestionAssociation, etc.) Â»

  2. **Construction de la commande de migration :**  
     - Une fois `<NomDuModule>` dÃ©terminÃ© (par infÃ©rence ou rÃ©ponse de lâ€™utilisateur), lâ€™agent gÃ©nÃ¨re la commande :  
       ```bash
       php artisan make:module-migration create_<nom_table>_table <NomDuModule>
       ```  
       oÃ¹ `<nom_table>` est le nom en minuscules et underscore de la table (par ex. `etat_evaluation_realisation_projets` pour Â« EtatEvaluationRealisationProjet Â»).

- **Exemple concret de dialogue attendu :**  
  1. **Utilisateur** : Â« CrÃ©er la table `EtatEvaluationRealisationProjet`. Â»  
  2. **Agent** (infÃ©rence) :  
     - Le nom contient â€œEtatâ€ et â€œRealisationProjetâ€ â‡’ correspond Ã  une table de suivi dâ€™Ã©valuation de projets â‡’ module probable : `PkgGestionTaches`.  
     - **Agent (rÃ©ponse)** :  
       ```
       Jâ€™ai dÃ©tectÃ© que Â« EtatEvaluationRealisationProjet Â» correspond au module â€œPkgGestionTachesâ€.  
       Voici la commande pour gÃ©nÃ©rer la migration :
       php artisan make:module-migration create_etat_evaluation_realisation_projets_table PkgGestionTaches
       ```
  3. **Cas dâ€™ambiguÃ¯tÃ©**  
     - **Utilisateur** : Â« CrÃ©er la table `SettingGlobal`. Â»  
     - **Agent (aucune correspondance claire)** :  
       ```
       Je nâ€™arrive pas Ã  dÃ©terminer dans quel module placer la table â€œSettingGlobalâ€.  
       Dans quel module souhaitez-vous la crÃ©er ? (par ex. : Core, PkgGestionTaches, PkgGestionAssociation, etc.)
       ```

- **Exemple dâ€™un fichier de migration conforme**  
  ```php
  <?php

  use Illuminate\Database\Migrations\Migration;
  use Illuminate\Database\Schema\Blueprint;
  use Illuminate\Support\Facades\Schema;

  return new class extends Migration
  {
      public function up()
      {
          Schema::create('etat_realisation_taches', function (Blueprint $table) {
              $table->id();

              // Colonne 'reference' obligatoire et unique
              $table->string('reference')->unique();

              $table->string('nom');
              $table->longText('description')->nullable();
              $table->boolean('is_editable_only_by_formateur')
                    ->default(false)
                    ->nullable();
              $table->foreignId('formateur_id')
                    ->constrained('formateurs')
                    ->onDelete('cascade');
              $table->foreignId('sys_color_id')
                    ->constrained('sys_colors');
              $table->timestamps();
          });
      } 

      public function down()
      {
          Schema::dropIfExists('etat_realisation_taches');
      }
  };


La commande pour migration : 

````bash
php artisan make:module-migration create_<nom_table>_table <NomDuModule>
````

<!-- ===== 6.3.Ajouter un Champ Calculable.md ===== -->

#### TÃ¢che : Ajouter un Champ Calculable

Pour ajouter un champ calculable dans une entitÃ©, il faut :

- CrÃ©er un champ avec lâ€™attribut `calculable = true`.
- DÃ©finir une requÃªte SQL permettant de calculer dynamiquement la valeur du champ.
- Cette requÃªte peut Ãªtre utilisÃ©e pour :
  - Afficher la valeur du champ dans une table.
  - Permettre le tri (`sortable`) et la recherche (`searchable`) si le champ est affichÃ© via la metadata `ShowInTable`.

> âš ï¸ Si aucune requÃªte nâ€™est fournie, la valeur du champ sera `null` par dÃ©faut.

---

## RequÃªte SQL

La requÃªte SQL permet de rendre un champ calculable exploitable dans lâ€™interface (tri, recherche).

**Exemple :** champ `nombre_realisation_taches_en_cours` dans l'entitÃ© `Apprenant` :

```sql
SELECT count(*)
FROM realisation_taches rt
JOIN realisation_projets rp ON rt.realisation_projet_id = rp.id
JOIN etat_realisation_taches ert ON rt.etat_realisation_tache_id = ert.id
WHERE rp.apprenant_id = apprenants.id AND ert.nom = 'En cours'
```

---

## Ã‰tapes de CrÃ©ation dâ€™un Champ Calculable

1. **Nom** : Nom du champ.
2. **Nom de la colonne / Relation** : 
   - Bien que les anciennes versions utilisaient des chemins relationnels (`competence.module.filiere_id`), la version actuelle privilÃ©gie une requÃªte SQL directe.
3. **Valeur affichÃ©e** : Le rÃ©sultat de la requÃªte sera utilisÃ© comme valeur du champ dans :
   - Le formulaire
   - Les colonnes de la table
4. **Attribut `calculable = true`**
5. **RequÃªte SQL** : 
   - Obligatoire pour les fonctionnalitÃ©s de tri et de recherche (avec `ShowInTable`).
   - Si absente, la valeur ne sera ni triable ni recherchable, et prendra `null`.

---

## Cas dâ€™Usage : Ajout de `filiere_id` Ã  lâ€™entitÃ© `Formation`

- **Type** : `Integer`
- **Relation logique** : `formation â†’ competence â†’ module â†’ filiere`
- **RequÃªte SQL** :

```sql
SELECT m.filiere_id
FROM formations f
JOIN competences c ON f.competence_id = c.id
JOIN modules m ON c.module_id = m.id
WHERE f.id = formations.id
```

---


## CrÃ©ation dâ€™un Champ avec `SelectOne`

Si le champ calculable est de type `Integer` et doit proposer un menu dÃ©roulant (select), on peut ajouter une metadata de type `Select`.

**Exemple :**

- EntitÃ© : `Formation`
- Champ : `filiere_id`
- Type : `Integer`
- Metadata Ã  ajouter :

```json
//TODO : en construction, la configuration JSOn n'est pas correct
// la configuration doit dÃ©termine le DataSource : Function, JSON, Enumeration, 
// La dÃ©termination doit Ãªtre avec NameSpace
{
  "name": "Select",
  "parameters": {
    "entity": "Filiere"
  }
}
```

<!-- ===== 6.5.Ajouter mÃ©thode dans Service.md ===== -->

#### âœ… Ajouter une mÃ©thode dans la classe Service

### ğŸ¯ Objectif  
CrÃ©er une nouvelle mÃ©thode mÃ©tier dans une classe `Service` tout en respectant la logique dÃ©jÃ  existante pour garantir **cohÃ©rence**, **rÃ©utilisabilitÃ©** et **maintenabilitÃ©**.



### La **classe `Service`** dans le projet Solicode-LMS joue un rÃ´le de **service mÃ©tier**, centralisant la logique fonctionnelle liÃ©e aux entitÃ©s du domaine. Elle est souvent utilisÃ©e comme intermÃ©diaire entre les contrÃ´leurs et les modÃ¨les, permettant de garder les contrÃ´leurs lÃ©gers et les traitements organisÃ©s.

---

### ğŸ¯ **Structure GÃ©nÃ©rale de la classe `Service`**

Dans ce projet, les services suivent une architecture orientÃ©e **hÃ©ritage** pour centraliser les comportements rÃ©utilisables :

#### 1. **BaseService** (Classe mÃ¨re)
- Localisation : `BaseService.php`
- Contient les mÃ©thodes gÃ©nÃ©riques :
  - `getModelClass()` : Retourne la classe du modÃ¨le.
  - `query()` : Fournit un builder de requÃªte pour le modÃ¨le.
  - `findOrFail($id)` : Trouve un enregistrement ou lÃ¨ve une exception.
  - `create($data)` / `update($model, $data)` / `delete($model)` : MÃ©thodes CRUD de base.
  - `getByReference($ref)` : RÃ©cupÃ©ration d'un enregistrement par rÃ©fÃ©rence.
  - Gestion des transactions avec `DB::transaction`.

#### 2. **BaseFormateurService** (Classe intermÃ©diaire)
- SpÃ©cifique aux modÃ¨les liÃ©s Ã  un `formateur`.
- Ã‰tend `BaseService`.
- Ajoute des mÃ©thodes comme :
  - `getFormateurQuery($formateurId)`
  - `getByReferenceAndFormateurId(...)`
  - `createWithFormateurId(...)`

#### 3. **FormateurService** (Exemple concret)
- Ã‰tend `BaseFormateurService`.
- Applique la logique spÃ©cifique au modÃ¨le `Formateur`.

---

### ğŸ“¦ **Exemple simplifiÃ©**

```php
// Exemple de service mÃ©tier pour gÃ©rer les "TÃ¢ches"
namespace App\Services;

use App\Models\Tache;
use Illuminate\Support\Facades\DB;

class TacheService extends BaseFormateurService
{
    protected function getModelClass(): string
    {
        return Tache::class;
    }

    public function validerTache(int $id, array $data)
    {
        return DB::transaction(function () use ($id, $data) {
            $tache = $this->findOrFail($id);
            $tache->etat = 'validÃ©e';
            $tache->save();
            return $tache;
        });
    }
}
```

---

### âœ… **Avantages de cette architecture**

- **RÃ©utilisabilitÃ©** : les traitements de base sont centralisÃ©s.
- **ClartÃ©** : la logique mÃ©tier est sÃ©parÃ©e des contrÃ´leurs.
- **TestabilitÃ©** : facilite les tests unitaires des services.
- **ExtensibilitÃ©** : possibilitÃ© d'ajouter des comportements sans toucher au cÅ“ur.

Souhaites-tu que je gÃ©nÃ¨re une **metadata Gapp** associÃ©e Ã  une opÃ©ration typique de ce service (comme `createWithFormateurId`, `getByReference`, etc.) ?


### ğŸ§± RÃ¨gles Ã  suivre

1. **RÃ©utilisation prioritaire des mÃ©thodes existantes**
   - Utiliser en prioritÃ© les mÃ©thodes CRUD fournies par le `CrudTrait` :
     - `all()`, `find()`, `create()`, `update()`, `destroy()`, `edit()`, `updateOnlyExistanteAttribute()`, `updateOrCreate()`, `getByReference()`, `createInstance()`
   - Utiliser les mÃ©thodes utilitaires :
     - `hasOrdreColumn()`, `getNextOrdre()`, `reorderOrdreColumn()`
   - Lors de lâ€™utilisation d'entitÃ©s secondaires (ex. : `RealisationTache`), **toujours passer par leur propre service dÃ©diÃ©** (ex. : `RealisationTacheService`) au lieu dâ€™un appel direct au modÃ¨le.

2. **CrÃ©er une mÃ©thode uniquement si elle est spÃ©cifique au mÃ©tier**
   - Exemple : `getEtatInitialByFormateur()`, `synchroniserTachesDuProjet($projetId)`
   - La mÃ©thode doit encapsuler un **traitement fonctionnel clair**.

3. **Utiliser les outils fournis par la classe `Service`**
   - `$this->model` pour manipuler l'entitÃ© principale
   - `$this->viewState`, `$this->sessionState` pour le contexte utilisateur
   - Injecter ou instancier les services secondaires de maniÃ¨re explicite :
     ```php
     $realisationTacheService = new RealisationTacheService();
     $realisationTacheService->create([...]);
     ```

4. **Encapsuler les traitements complexes**
   - Si la logique comporte plusieurs Ã©tapes (ex. crÃ©ation dâ€™un projet et ses tÃ¢ches), la diviser en **mÃ©thodes privÃ©es**, ou bien utiliser des services mÃ©tiers complÃ©mentaires.

---

### ğŸ§° Liste des mÃ©thodes disponibles

#### ğŸ“¦ MÃ©thodes CRUD (`CrudTrait`)

- `all()`
- `find(int $id)`
- `create(array|Model $data)`
- `update($id, array $data)`
- `destroy($id)`
- `edit($id)`
- `updateOnlyExistanteAttribute($id, array $data)`
- `updateOrCreate(array $attributes, array $values)`
- `getByReference(string $reference)`
- `createInstance(array $data = [])`

#### âš™ï¸ MÃ©thodes utilitaires internes

- `hasOrdreColumn()`
- `getNextOrdre()`
- `reorderOrdreColumn(?int $ancienOrdre, int $nouvelOrdre, int $idEnCours = null)`

---

### ğŸ’¡ Exemples de mÃ©thodes mÃ©tier valides

- `getTachesByProjetId(int $projetId)`
- `synchroniserRealisationTaches(int $realisationProjetId)` â†’ via `RealisationTacheService`
- `getDefaultEtatByFormateurId(int $formateurId)`
- `dupliquerAvecRelations(int $idOriginal)`

<!-- ===== 6.8.Ajout d'un Nouveau Widget.md ===== -->

# ğŸ“š Documentation - Ajout d'un Nouveau Widget dans Solicode-LMS


## 1. Introduction

Un **widget** est un composant dynamique affichÃ© sur le tableau de bord des utilisateurs.  
Chaque widget est dÃ©fini dans la table **`widgets`** et personnalisÃ© par utilisateur via **`widget_utilisateurs`**.

L'objectif est de configurer un widget en insÃ©rant un enregistrement dans `widgets` accompagnÃ© d'une configuration JSON (`parameters`) pour en dÃ©finir le comportement et l'affichage.

---

## 2. Composition dâ€™un Widget

| Champ               | Description                                                             | Exemple |
|---------------------|-------------------------------------------------------------------------|---------|
| `ordre`             | Position dâ€™affichage sur le tableau de bord.                           | `2` |
| `name`              | Nom technique unique.                                                  | `TachesEnCours` |
| `label`             | LibellÃ© visible par l'utilisateur.                                     | `Nombre de tÃ¢ches en cours` |
| `type_id`           | Type de widget (`1` = valeur simple, `3` = tableau, etc.).              | `1` |
| `model_id`          | ModÃ¨le concernÃ© (ex: `Apprenant`, `RealisationTache`, etc.).            | `96` |
| `operation_id`      | Type dâ€™opÃ©ration (`1 = count`, `3 = parameters`, etc.).                 | `1` |
| `color`             | Couleur Bootstrap (`success`, `info`, etc.).                            | `success` |
| `icon`              | IcÃ´ne FontAwesome facultative.                                          | `fa-user` |
| `sys_color_id`      | Couleur personnalisÃ©e (`sys_colors`).                                   | `3` |
| `reference`         | UUID unique.                                                            | `5e5225ca-8a32-4316-949a-7aede93818cc` |
| `section_widget_id` | ID de la section (groupe) d'affichage.                                  | `1` |
| `parameters`        | JSON dÃ©crivant les comportements et filtres dynamiques du widget.       | Voir ci-dessous |

---

## 3. Structure du champ `parameters`

Le champ `parameters` est un JSON structurant les comportements suivants :

| ClÃ©            | Description |
|----------------|-------------|
| `link`         | DÃ©finir la route d'accÃ¨s lors du clic sur le widget. |
| `roles`        | DÃ©finir des filtres spÃ©cifiques selon le rÃ´le utilisateur (`admin`, `formateur`, `apprenant`). |
| `dataSource`   | DÃ©finir la mÃ©thode de service Ã  appeler pour charger les donnÃ©es. |
| `conditions`   | Ajouter des filtres statiques sur les modÃ¨les (requÃªte DSL). |
| `tableUI`      | Structurer les colonnes si `type_id = 3` (affichage en tableau). |
| `order_by`     | DÃ©finir lâ€™ordre dâ€™affichage (`column`, `direction`). |
| `limit`        | Limiter le nombre de rÃ©sultats affichÃ©s. |

---

### ğŸ”¥ Rappel important - Utilisation de `roles`

- **`roles`** permet de dÃ©finir des **conditions de filtrage spÃ©cifiques par rÃ´le** (admin, formateur, apprenant).
- Tous les critÃ¨res de filtrage (`user_id`, `etat`, etc.) peuvent Ãªtre dÃ©finis ici pour adapter dynamiquement les rÃ©sultats selon le rÃ´le connectÃ©.

```json
"roles": {
  "admin": {
    "etatRealisationTache.workflowTache.code": "EN_COURS"
  },
  "apprenant": {
    "realisationProjet.apprenant.user_id": "#user_id",
    "etatRealisationTache.workflowTache.code": "EN_COURS"
  }
}
```

---

### âš™ï¸ Deux maniÃ¨res de rÃ©cupÃ©rer les donnÃ©es

| MÃ©thode      | Description |
|--------------|-------------|
| `dataSource` | Appel dâ€™une mÃ©thode spÃ©cifique dâ€™un Service mÃ©tier (ex : `getTachesEnCours()`) |
| `conditions` | RequÃªte directe sur le modÃ¨le via des filtres (`where`) |

---

## 4. Exemple Complet dâ€™un Widget JSON

```json
{
  "link": {
    "route_name": "realisationTaches.index",
    "route_params": {
      "filter.realisationTache.etatRealisationTache.WorkflowTache.Code": "EN_COURS"
    }
  },
  "roles": {
    "admin": {
      "etatRealisationTache.workflowTache.code": "EN_COURS"
    },
    "apprenant": {
      "realisationProjet.apprenant.user_id": "#user_id",
      "etatRealisationTache.workflowTache.code": "EN_COURS"
    }
  },
  "dataSource": null,
  "conditions": {},
  "tableUI": [
    {
      "key": "tache.titre",
      "label": "TÃ¢che",
      "order": 1
    },
    {
      "key": "realisationProjet.apprenant",
      "label": "Apprenant",
      "order": 2
    }
  ],
  "order_by": {
    "column": "updated_at",
    "direction": "desc"
  },
  "limit": 5
}
```

---

## 5. Ã‰tapes pour crÃ©er un Nouveau Widget

### 1ï¸âƒ£ DÃ©finir le besoin
- Quel modÃ¨le ?
- Quelle opÃ©ration (`count`, `sum`, `parameters`) ?
- Quel affichage (`simple`, `tableau`) ?
- Quelle source (`dataSource` ou `conditions`) ?

### 2ï¸âƒ£ Construire le JSON `parameters`
- DÃ©finir `link`, `roles`, `dataSource` ou `conditions`.
- Ajouter `tableUI` si besoin (`type_id = 3`).

### 3ï¸âƒ£ InsÃ©rer dans la Base de DonnÃ©es

```sql
INSERT INTO widgets 
(ordre, name, label, type_id, model_id, operation_id, color, icon, sys_color_id, reference, section_widget_id, parameters)
VALUES 
(3, 'ApprenantsSansTache', 'Apprenants sans tÃ¢che Ã  faire', 3, 11, 3, 'info', 'fa-user', 5, 'UUID-GÃ‰NÃ‰RÃ‰', 1, '{...JSON...}');
```

âš ï¸ `reference` doit Ãªtre **unique** (UUID).

### 4ï¸âƒ£ Synchroniser pour les Utilisateurs
- Utiliser `WidgetUtilisateurService::syncWidgetsFromRoles()` pour rÃ©gÃ©nÃ©rer la liste des widgets selon les rÃ´les.

---

## 6. Bonnes Pratiques

- Utiliser les **placeholders dynamiques** `#user_id`, `#apprenant_id`, `#formateur_id`.
- Toujours limiter le nombre de lignes avec `limit` pour Ã©viter les lenteurs.
- Bien vÃ©rifier la cohÃ©rence entre `type_id`, `operation_id`, `tableUI`.
- PrÃ©fÃ©rer `dataSource` pour les traitements complexes et `conditions` pour les cas simples.

---

# ğŸ“¦ RÃ©sumÃ© - ModÃ¨le JSON PrÃªt Ã  Remplir

```json
{
  "link": {
    "route_name": "",
    "route_params": {}
  },
  "roles": {
    "admin": {},
    "formateur": {},
    "apprenant": {}
  },
  "dataSource": "",
  "conditions": {},
  "tableUI": [],
  "order_by": {
    "column": "",
    "direction": "desc"
  },
  "limit": 5
}
```

<!-- ===== 6.Exemples et cas dâ€™usage.md ===== -->

### 6. ğŸ” Exemples et cas dâ€™usage

#### ğŸ”¹ TÃ¢ches typiques Ã  traiter par lâ€™agent

Lâ€™agent doit Ãªtre capable de rÃ©pondre efficacement aux besoins courants de dÃ©veloppement et de maintenance dans lâ€™application **Sollms**, en respectant la structure existante et les bonnes pratiques du projet.


#### ğŸ”¹ CapacitÃ© dâ€™adaptation aux contextes variÃ©s

Lâ€™agent doit sâ€™adapter intelligemment au contexte dâ€™utilisation et aux profils des utilisateurs :

* ÃŠtre capable de **gÃ©nÃ©raliser une solution** pour quâ€™elle soit applicable Ã  dâ€™autres entitÃ©s ou modules (logique gÃ©nÃ©rique).
* Adapter le **niveau de dÃ©tail des explications** :

  * Pour un **apprenant**, fournir des explications claires, pÃ©dagogiques et progressives.
  * Pour un **formateur**, proposer des rÃ©ponses synthÃ©tiques et directement exploitables.
* Sâ€™assurer que chaque exemple ou fonctionnalitÃ© soit **adaptable aux trois rÃ´les principaux** de lâ€™application :

  * **Administrateur** : configuration, supervision.
  * **Formateur** : gestion pÃ©dagogique, suivi des tÃ¢ches.
  * **Apprenant** : exÃ©cution, consultation et interaction.



**Exemples de tÃ¢ches frÃ©quentes :**

