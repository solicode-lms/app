Parfait Fouad ! Voilà les **trois fichiers complets** avec les ajustements demandés — sans changer le comportement existant.
Ce que ça ajoute concrètement :

* **Entrée (Enter) dans `<pre><code>` (mode normal)** : insère un **retour à la ligne**. `Ctrl+Enter` **ou** **Double-Enter** sortent du bloc et créent **un nouveau paragraphe** juste après.&#x20;
* **Entrée (Enter) en mode CodeJar** : fonctionne naturellement (saut de ligne). `Ctrl+Enter` sort et crée **un paragraphe** après, `Esc` sort **sans paragraphe**.
* **Coller (Paste)** : toujours en **texte brut** dans les blocs de code / CodeJar.

---

### `/modules/.../CodeHelpers.js`

```js
// CodeHelpers.js
// Utilitaires communs : caret/selection, insertion, classes language-xxx,
// nettoyage Prism et wrappers CodeJar.

export default class CodeHelpers {
  // Map des alias → clés Prism réelles
  static prismKey(lang) {
    if (!lang) return 'javascript';
    const map = { html: 'markup', js: 'javascript' };
    return map[lang] || lang;
  }

  static getSelection() {
    return window.getSelection ? window.getSelection() : document.getSelection();
  }

  static getCodeAncestorFromSelection() {
    const sel = this.getSelection();
    if (!sel || sel.rangeCount === 0) return null;
    let node = sel.anchorNode;
    if (!node) return null;
    if (node.nodeType === 3) node = node.parentNode;
    return node && node.closest ? node.closest('pre code') : null;
  }

  static insertTextAtCursor(text) {
    const sel = this.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0);
    range.deleteContents();
    const textNode = document.createTextNode(text);
    range.insertNode(textNode);
    range.setStartAfter(textNode); range.setEndAfter(textNode);
    sel.removeAllRanges(); sel.addRange(range);
  }

  static insertNodeAtCursor(node) {
    const sel = this.getSelection();
    if (!sel || sel.rangeCount === 0) {
      const editable = document.querySelector('.note-editable');
      if (editable) editable.appendChild(node);
      return;
    }
    const range = sel.getRangeAt(0);
    range.collapse(true); range.insertNode(node);
  }

  static placeCaretAtEnd(el) {
    const range = document.createRange(); const sel = this.getSelection();
    range.selectNodeContents(el); range.collapse(false);
    sel.removeAllRanges(); sel.addRange(range);
  }

  static placeCaretAtStart(el) {
    const range = document.createRange(); const sel = this.getSelection();
    range.selectNodeContents(el); range.collapse(true);
    sel.removeAllRanges(); sel.addRange(range);
  }

  static insertPlainTextIntoContentEditable(el, text) {
    const sel = this.getSelection(); if (!sel || sel.rangeCount === 0) return;
    const range = sel.getRangeAt(0); if (!el.contains(range.startContainer)) return;
    range.deleteContents(); range.insertNode(document.createTextNode(text));
    range.collapse(false); sel.removeAllRanges(); sel.addRange(range);
  }

  static setCodeLanguage(codeEl, newLang) {
    [...codeEl.classList].forEach(c => { if (/^language-/.test(c)) codeEl.classList.remove(c); });
    codeEl.classList.add(`language-${newLang}`);
  }

  static getCodeLanguage(codeEl) {
    const cl = [...codeEl.classList].find(c => /^language-/.test(c));
    return cl ? cl.replace(/^language-/, '') : null;
  }

  static cleanCodeElement(codeEl) {
    const lang = this.getCodeLanguage(codeEl);
    const text = codeEl.textContent;
    codeEl.innerHTML = '';
    codeEl.textContent = text;
    if (lang) this.setCodeLanguage(codeEl, lang);
  }

  /**
   * Nettoie tout le HTML d’un éditeur Summernote :
   * - convertit les wrappers CodeJar restants en <pre><code>
   * - supprime tout markup Prism dans les <code>
   */
  static cleanPrismFromHtml(html) {
    const container = document.createElement('div');
    container.innerHTML = html;

    // Convertir d’éventuels wrappers CodeJar résiduels
    container.querySelectorAll('.sn-codejar-wrapper').forEach(wrapper => {
      const ed = wrapper.querySelector('.sn-codejar-editor');
      const lang = wrapper.dataset.lang || 'javascript';
      const pre = document.createElement('pre');
      const code = document.createElement('code');
      code.className = `language-${lang}`;
      code.textContent = ed ? ed.textContent : '';
      pre.appendChild(code);
      wrapper.parentNode.replaceChild(pre, wrapper);
    });

    // Nettoyer chaque <pre><code> (supprimer <span class="token ...">)
    container.querySelectorAll('pre code').forEach(code => this.cleanCodeElement(code));
    return container.innerHTML;
  }
}
```

---

### `/modules/.../CodeBlockEditor.js`

```js
// CodeBlockEditor.js
// Gestion d’un bloc <pre><code> en mode édition CodeJar + Prism
// (ouverture, rehighlight, sortie, clic hors, paste texte brut)

import { CodeJar } from 'codejar';
import Prism from 'prismjs';
import 'prismjs/themes/prism.css';

// Langages nécessaires
import 'prismjs/components/prism-json';
import 'prismjs/components/prism-javascript';
import 'prismjs/components/prism-markup';   // HTML = "markup"
import 'prismjs/components/prism-css';
import 'prismjs/components/prism-php';
import 'prismjs/components/prism-bash';
// Dépendances utiles
import 'prismjs/components/prism-clike';
import 'prismjs/components/prism-markup-templating';

import CodeHelpers from './CodeHelpers.js';

export default class CodeBlockEditor {
  static CLASS_WRAPPER = 'sn-codejar-wrapper';
  static CLASS_EDITOR  = 'sn-codejar-editor';

  constructor(options = {}) {
    this.options = {
      codeJarTab: '  ',
      onFinish: null,   // callback(preEl, addParagraphAfter)
      ...options
    };
    this.jar = null;
    this.wrapper = null;
    this.editorEl = null;
    this.lang = 'javascript';
    this._clickOutsideHandler = null;
    this._rehighlight = () => {};

    // ✅ Registre global minimal pour Summernote.onChange
    if (typeof window !== 'undefined') {
      if (!window.codejarInstances || !(window.codejarInstances instanceof Map)) {
        window.codejarInstances = new Map();
      }
    }
  }

  isActive() { return !!this.jar && !!this.wrapper; }
  getLanguage() { return this.lang; }

  setLanguage(newLang) {
    this.lang = newLang || 'javascript';
    this._rehighlight();
  }

  getText() { return this.editorEl ? this.editorEl.textContent : ''; }

  startOnCodeEl(codeEl) {
    if (this.isActive()) return;

    // Nettoyer Prism dans ce bloc
    CodeHelpers.cleanCodeElement(codeEl);
    const pre = codeEl.closest('pre');

    // Wrapper + éditeur contenteditable
    const wrapper = document.createElement('div');
    wrapper.className = CodeBlockEditor.CLASS_WRAPPER;
    wrapper.style.position = 'relative';

    const editor = document.createElement('div');
    editor.className = CodeBlockEditor.CLASS_EDITOR;
    editor.contentEditable = 'true';
    Object.assign(editor.style, {
      whiteSpace: 'pre',
      fontFamily: 'monospace',
      fontSize: '0.95em',
      border: '3px solid #ddd',
      borderRadius: '4px',
      padding: '8px',
      background: '#f8f8f8'
    });
    editor.textContent = codeEl.textContent;

    pre.parentNode.replaceChild(wrapper, pre);
    wrapper.appendChild(editor);

    // Langue active
    this.lang = CodeHelpers.getCodeLanguage(codeEl) || 'javascript';
    wrapper.dataset.lang = this.lang;

    // Highlight (appelé par CodeJar après chaque modif)
    const rehighlight = (ed) => {
      const code = ed.textContent;
      const prismKey = CodeHelpers.prismKey(this.lang);
      const grammar = Prism.languages[prismKey];
      if (!grammar) return;
      ed.innerHTML = Prism.highlight(code, grammar, prismKey);
    };
    this._rehighlight = () => rehighlight(editor);

    // Instancier CodeJar (pas besoin de new) + premier highlight
    this.jar = CodeJar(editor, rehighlight, { tab: this.options.codeJarTab });
    rehighlight(editor);

    // ✅ Enregistrer l’instance pour Summernote.onChange
    try {
      if (typeof window !== 'undefined' && window.codejarInstances instanceof Map) {
        window.codejarInstances.set(editor, this.jar);
      }
    } catch (_) {}

    // Bloquer Summernote pendant l’édition (mais pas 'input' !)
    const stopEv = (ev) => ev.stopPropagation();
    editor.addEventListener('keydown', stopEv, true);
    editor.addEventListener('keypress', stopEv, true);
    editor.addEventListener('keyup', stopEv, true);
    // ⚠️ ne pas stopper 'input', sinon CodeJar ne déclenche pas son rehighlight
    editor.addEventListener('drop', (e) => { e.preventDefault(); }, true);

    // Fallback : forcer un rehighlight manuel sur chaque input
    editor.addEventListener('input', () => {
      requestAnimationFrame(() => rehighlight(editor));
    });

    // Coller en texte brut
    editor.addEventListener('paste', (e) => {
      e.preventDefault();
      let text = (e.clipboardData || window.clipboardData)?.getData('text/plain') || '';
      text = text.replace(/\r\n?/g, '\n');
      CodeHelpers.insertPlainTextIntoContentEditable(editor, text);
    });

    // Raccourcis de sortie
    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.ctrlKey) { e.preventDefault(); this.finish(true); }
      else if (e.key === 'Escape')       { e.preventDefault(); this.finish(false); }
      // (Enter simple = géré nativement par CodeJar → nouvelle ligne)
    });

    // Click hors du wrapper => sortie
    const snRoot = wrapper.closest('.note-editor') || document;
    const clickOutsideToExit = (ev) => {
      if (!this.isActive()) return;
      const target = ev.target;
      if ((snRoot && snRoot.contains(target)) && !wrapper.contains(target)) {
        this.finish(false);
      }
    };
    document.addEventListener('mousedown', clickOutsideToExit, true);
    this._clickOutsideHandler = clickOutsideToExit;

    // Mémoriser refs et focus
    this.wrapper = wrapper;
    this.editorEl = editor;
    CodeHelpers.placeCaretAtEnd(editor);
  }

  finish(addParagraphAfter = false) {
    if (!this.isActive()) return;

    const text = this.getText();
    const lang = this.lang || this.wrapper.dataset.lang || 'javascript';

    // ✅ Retirer du registre global AVANT reset
    try {
      if (typeof window !== 'undefined' && window.codejarInstances instanceof Map && this.editorEl) {
        window.codejarInstances.delete(this.editorEl);
      }
    } catch (_) {}

    // Détruire CodeJar
    this.jar.destroy?.();
    this.jar = null;

    // Retirer le handler "click dehors"
    if (this._clickOutsideHandler) {
      document.removeEventListener('mousedown', this._clickOutsideHandler, true);
      this._clickOutsideHandler = null;
    }

    // Reconstruire un <pre><code> propre
    const pre = document.createElement('pre');
    const code = document.createElement('code');
    code.className = `language-${lang}`;
    code.textContent = text;
    pre.appendChild(code);

    // Remplacer le wrapper par <pre>
    const parent = this.wrapper.parentNode;
    parent.replaceChild(pre, this.wrapper);

    // RAZ refs
    this.wrapper = null;
    this.editorEl = null;

    // Focus après
    if (addParagraphAfter) {
      const p = document.createElement('p'); p.innerHTML = '<br>';
      pre.parentNode.insertBefore(p, pre.nextSibling);
      CodeHelpers.placeCaretAtStart(p);
    } else {
      CodeHelpers.placeCaretAtEnd(code);
    }

    // Callback externe éventuel
    if (typeof this.options.onFinish === 'function') {
      this.options.onFinish(pre, addParagraphAfter);
    }
  }
}
```

---

### `/modules/.../SummernoteCodeManager.js`

```js
// SummernoteCodeManager.js
// Intégration Summernote (toolbar, dblclick, Enter/Tab, paste, clean avant sauvegarde, autoStart)
// S’appuie sur CodeHelpers + CodeBlockEditor

import CodeHelpers from './CodeHelpers.js';
import CodeBlockEditor from './CodeBlockEditor.js';

export default class SummernoteCodeManager {
  static defaultOptions = {
    languages: {
      php: 'PHP',
      javascript: 'JavaScript',
      html: 'HTML',
      css: 'CSS',
      json: 'JSON',
      bash: 'Bash'
    },
    placeholderCommentByLang: (lang) => ({
      php: "/* code */",
      javascript: "/* code */",
      html: "<!-- code -->",
      css: "/* code */",
      json: "{\n  \"key\": \"value\"\n}",
      bash: "# code"
    }[lang] || "/* code */"),
    doubleEnterDelay: 320,  // Double-Enter pour sortir du bloc
    codeJarTab: '  ',
    height: 120,
    autoStart: false
  };

  // ---------- PUBLIC API ----------
  static initAll(selector, opts = {}) {
    const $ = window.jQuery || window.$;
    $(selector).each((_, el) => this.initTextArea($(el), opts));
  }

  static initTextArea($textarea, opts = {}) {
    const $ = window.jQuery || window.$;
    const options = { ...this.defaultOptions, ...opts };

    if (!$ || !$.summernote) throw new Error('SummernoteCodeManager: Summernote requis.');

    // Initialiser Summernote (avec bouton dropdown "langue")
    if (!$textarea.data('summernote')) {
      $textarea.summernote({
        height: options.height,
        toolbar: [
          ['style', ['style']],
          ['font', ['bold', 'italic', 'underline', 'clear']],
          ['para', ['ul', 'ol', 'paragraph']],
          ['insert', ['link', 'picture', 'table']],
          ['view', ['fullscreen', 'codeview']],
          ['codetools', ['codeLanguage']]
        ],
        styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3'],
        buttons: {
          codeLanguage: this._buildLanguageDropdownFactory(options)
        },
        // ✅ Synchroniser les CodeJar actifs sur chaque changement Summernote
        callbacks: {
          onChange: function () {
            const instances = (window.codejarInstances || window.CodeJarInstances || null);
            if (instances && typeof instances.forEach === 'function') {
              instances.forEach((jar, editor) => {
                if (!editor || !editor.isConnected) return;
                try {
                  let pos = jar.save();
                  jar.updateCode(editor.textContent);
                  jar.restore(pos);
                } catch (_) {}
              });
            }
          }
        }
      });
    } else {
      this._injectLanguageButton($textarea, this._buildLanguageDropdownFactory(options));
    }

    const $editor = $textarea.next('.note-editor');
    const $editable = $editor.find('.note-editable');

    // État local pour cet éditeur
    const state = {
      lastEnterTime: 0,
      editor: new CodeBlockEditor({
        codeJarTab: options.codeJarTab,
        onFinish: () => { /* hook possible */ }
      })
    };
    $editable.data('sncm-state', state);

    // Double-clic sur <pre><code> => activer CodeJar
    $editable.on('dblclick', 'pre code', (e) => {
      e.preventDefault();
      state.editor.startOnCodeEl(e.currentTarget);
    });

    // Enter/Tab dans <pre><code> quand CodeJar n’est PAS actif
    $editable.on('keydown', (e) => {
      if (state.editor.isActive()) return; // géré par CodeJar
      const codeEl = CodeHelpers.getCodeAncestorFromSelection();
      if (!codeEl) return;

      if (e.key === 'Enter') {
        const now = Date.now();
        const isDoubleEnter = (now - state.lastEnterTime) <= options.doubleEnterDelay;
        state.lastEnterTime = now;
        e.preventDefault();

        if (e.ctrlKey || isDoubleEnter) {
          const pre = codeEl.closest('pre');
          CodeHelpers.cleanCodeElement(codeEl);
          const p = document.createElement('p'); p.innerHTML = '<br>';
          pre.parentNode.insertBefore(p, pre.nextSibling);
          CodeHelpers.placeCaretAtStart(p);
        } else {
          CodeHelpers.insertTextAtCursor('\n');
        }
      } else if (e.key === 'Tab') {
        e.preventDefault();
        CodeHelpers.insertTextAtCursor(options.codeJarTab);
      }
    });

    // Coller en texte brut quand on est dans un bloc code (ou dans CodeJar)
    $editable.on('paste', (we) => {
      const e = we.originalEvent || we;
      const codeEl = CodeHelpers.getCodeAncestorFromSelection();
      if (codeEl || state.editor.isActive()) {
        e.preventDefault();
        let text = (e.clipboardData || window.clipboardData)?.getData('text/plain') || '';
        text = text.replace(/\r\n?/g, '\n');
        CodeHelpers.insertTextAtCursor(text);
      }
    });

    // Nettoyage avant sync → textarea
    $textarea.on('summernote.change', (_, contents) => {
      $textarea.val(CodeHelpers.cleanPrismFromHtml(contents));
    });

    // Nettoyage juste avant submit du formulaire
    const $form = $textarea.closest('form');
    if ($form.length) {
      $form.on('submit', () => {
        const cleaned = CodeHelpers.cleanPrismFromHtml($textarea.summernote('code'));
        $textarea.val(cleaned);
      });
    }

    // 👉 Option : ouvrir automatiquement le 1er bloc code au démarrage
    if (options.autoStart) {
      setTimeout(() => {
        const firstCode = $editable.find('pre code').get(0);
        if (firstCode && !state.editor.isActive()) {
          state.editor.startOnCodeEl(firstCode);
        }
      }, 0);
    }
  }

  // ---------- UI: bouton dropdown ----------
  static _buildLanguageDropdownFactory(options) {
    return (context) => {
      const $ = window.jQuery || window.$;
      const ui = ($.summernote && $.summernote.ui) || (context && context.ui);
      const $note = context && context.$note ? context.$note : null;
      if (!ui) throw new Error('SummernoteCodeManager: UI helper indisponible.');

      const itemsLabels = Object.values(options.languages);
      const group = ui.buttonGroup([
        ui.button({
          className: 'dropdown-toggle',
          contents: '<i class="note-icon-code"></i> <span class="caret"></span>',
          tooltip: 'Code language',
          data: { toggle: 'dropdown' }
        }),
        ui.dropdown({
          className: 'dropdown-menu sn-code-lang',
          items: itemsLabels,
          click: (e) => {
            e.preventDefault();
            const label = $(e.target).text().trim();
            const lang = SummernoteCodeManager._langFromLabel(label, options) || 'javascript';
            if ($note) SummernoteCodeManager._onPickLanguage(lang, $note, options);
          }
        })
      ]);
      return group.render();
    };
  }

  static _injectLanguageButton($textarea, buttonFactory) {
    const context = $textarea.data('summernote');
    if (!context) return;
    const $toolbar = $textarea.next('.note-editor').find('.note-toolbar');
    if ($toolbar.find('.sn-code-lang').length) return;
    const html = buttonFactory(context);
    $toolbar.append(html);
  }

  static _langFromLabel(label, options) {
    for (const [k, v] of Object.entries(options.languages)) if (v === label) return k;
    return null;
  }

  // ---------- Choix de langue ----------
  static _onPickLanguage(lang, $textarea, options) {
    const $editor = $textarea.next('.note-editor');
    const $editable = $editor.find('.note-editable');
    const state = $editable.data('sncm-state');

    // Si CodeJar est actif → changer la langue et rehighlight en live
    if (state && state.editor && state.editor.isActive()) {
      state.editor.setLanguage(lang);
      return;
    }

    // Sinon, si curseur dans <pre><code> → MAJ classe seulement
    const codeEl = CodeHelpers.getCodeAncestorFromSelection();
    if (codeEl) {
      CodeHelpers.setCodeLanguage(codeEl, lang);
      return;
    }

    // Sinon → insérer un nouveau bloc code
    const pre = document.createElement('pre');
    const code = document.createElement('code');
    code.className = `language-${lang}`;
    code.textContent = options.placeholderCommentByLang(lang);
    pre.appendChild(code);
    CodeHelpers.insertNodeAtCursor(pre);
    CodeHelpers.placeCaretAtEnd(code);
  }
}
```

---

#### Notes rapides d’usage

* **Saut de ligne dans code** : Enter = `\n`, **Tab** = 2 espaces (configurable `codeJarTab`).&#x20;
* **Sortie et nouveau paragraphe** : `Ctrl+Enter` (mode normal et CodeJar) ; ou **Double-Enter** (mode normal).&#x20;
* **Sortie sans paragraphe** : `Esc` (CodeJar).
* **Paste en texte brut** : dans les deux modes.

Si tu veux que **Shift+Enter** fasse aussi un retour à la ligne (sans quitter), je peux l’ajouter de la même manière (ça ne cassera rien).
