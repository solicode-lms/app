# **Observer dans Laravel & Cache des Champs Calculables : Bonne ou Mauvaise Idée ?**

## **1. Qu’est-ce qu’un Observer dans Laravel ?**

Dans Laravel, un **Observer** est une classe qui permet de "surveiller" les événements d’un modèle Eloquent (ex : `creating`, `updating`, `deleted`).
Plutôt que de mélanger la logique métier dans les modèles ou contrôleurs, les **Observers** centralisent les actions déclenchées lors de certains événements.

**Exemple simple :**

```php
class RealisationChapitreObserver
{
    public function updated(RealisationChapitre $chapitre)
    {
        \Log::info("Le chapitre {$chapitre->id} a été mis à jour.");
    }
}
```

**Enregistrement de l’observer :**

```php
RealisationChapitre::observe(RealisationChapitreObserver::class);
```

Désormais, chaque `update()` sur `RealisationChapitre` déclenche automatiquement la méthode `updated()` de l’observer.

---

## **2. Pourquoi utiliser un champ `progression_cache` ?**

Certains champs (comme une **progression en %**) sont **calculables dynamiquement**. Par exemple, la progression d’une `UA` peut être calculée à partir du nombre de chapitres terminés :

$$
progression = \frac{\text{chapitres validés}}{\text{chapitres totaux}} \times 100
$$

**Problème :**

* Si on recalcule ce pourcentage à chaque affichage (via une relation `count()`), on multiplie les requêtes SQL.
* Sur de gros volumes (exemple : 10 000 chapitres), la performance se dégrade.

**Solution :**

* Ajouter un champ **`progression_cache`** qui stocke la valeur calculée.
* Ce champ est mis à jour automatiquement **via un Observer** quand les données de base changent (ex : un chapitre validé ou annulé).

---

## **3. Avantages du `progression_cache`**

### **Performance améliorée**

* Pas besoin de recalculer à chaque requête, la valeur est déjà prête.
* Réduit le nombre de jointures ou de requêtes complexes.

### **Simplicité d’affichage**

* Accès direct à `$ua->progression_cache` sans logique métier répétée dans les vues ou API.

### **Automatisation via `Observer`**

* Pas de risque d’oublier de mettre à jour la progression : l’Observer se déclenche automatiquement à chaque événement.

---

## **4. Inconvénients et risques**

### **Risque de désynchronisation**

* Si l’Observer est mal configuré ou qu’une mise à jour en masse (`bulk update`) ne déclenche pas les événements Eloquent, le cache peut devenir faux.

### **Complexité accrue**

* Il faut penser à maintenir ce cache **partout** où la donnée source est modifiée (exemple : suppression d’un chapitre).

### **Coût de maintenance**

* Nécessite des tests unitaires pour vérifier que le cache est bien recalculé.

---

## **5. Mon avis : est-ce une bonne pratique ?**

> **Oui, c’est une bonne pratique si :**
>
> * La donnée calculée (ex. progression) est **lente ou coûteuse à calculer**.
> * Tu as **beaucoup d’utilisateurs ou de requêtes** sur ces données.
> * Tu mets en place une **stratégie claire de recalcul via Observer**.

> **Non, ce n’est pas nécessaire si :**
>
> * La donnée est rapide à calculer (ex : 2-3 chapitres à compter).
> * Les volumes de données sont faibles (moins de 1 000 enregistrements).
> * Le risque de désynchronisation est plus grave que le gain de performance.

---

## **6. Exemple pratique – Observer + progression\_cache**

1. **Ajouter `progression_cache` dans la table :**

```php
$table->float('progression_cache')->default(0);
```

2. **Observer pour recalculer :**

```php
class RealisationChapitreObserver
{
    public function updated(RealisationChapitre $chapitre)
    {
        $ua = $chapitre->realisationUA;
        $ua->updateProgressionCache();
    }
}
```

3. **Méthode dans le modèle `RealisationUA` :**

```php
public function updateProgressionCache()
{
    $total = $this->chapitres()->count();
    $valides = $this->chapitres()
        ->whereHas('etat', fn($q) => $q->where('nom', 'Validé'))
        ->count();

    $this->progression_cache = $total > 0 ? ($valides / $total) * 100 : 0;
    $this->saveQuietly();
}
```

---

## **7. Conclusion**

* **Le duo `Observer + progression_cache`** est très utile pour **optimiser les performances** quand une donnée calculable est fréquemment consultée.
* Cependant, il faut **garantir la cohérence** du cache en mettant en place des **Observers bien testés**.
* Dans les projets à faible volume, **un calcul "à la volée" via accessor** (sans cache) reste souvent suffisant.

---

### **Prochaine étape :**

Veux-tu que je te **prépare un modèle d’article technique** (en markdown) que tu pourras publier sur un blog ou la documentation interne, **avec exemples de code complets et comparatif "cache vs calcul direct"** ?
