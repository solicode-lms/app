# Stratégie d’ensemble (bottom-up, idempotente)

1. **Source of truth**
   La granularité la plus fine est `RealisationTache`. Tout le reste (Microcompétence → UA → Chapitre) est **agrégé** à partir d’elle.

2. **Déclencheur unique**
   À chaque `created|updated|deleted` de `RealisationTache` (si champs touchés ∈ {`etat_id`, `note`, `is_live_coding`}):

   * Émettre un **événement de domaine** `TacheRealisationChanged`.
   * Un **listener** appelle un **AggregationService** qui recalcule en cascade:
     `RealisationMicrocompetence` → `RealisationUa` → `RealisationChapitre`.

3. **Dé-bouncing & performance**

   * Le listener **déclare un Job unique** (clé: `apprenant_id:projet_id:microcompetence_id`) avec un léger délai (ex. 1–2s) pour coalescer plusieurs updates rapides.
   * Utiliser `Cache::lock()` (ou `withoutOverlapping()` si Horizon) pour éviter les recalculs concurrents.

4. **Champs cache côté agrégats**
   Dans chaque table d’agrégat (`realisation_microcompetences`, `realisation_uas`, `realisation_chapitres`), prévoir et **mettre à jour uniquement**:

   * `progression_cache` (TINYINT 0–100)
   * `note_cache` (DECIMAL(5,2) nullable)
   * `etat_code` (VARCHAR)

   - `last_computed_at` (timestamp) si utile.

---

# Règles de calcul (claires et constantes)

## A. États utiles côté tâche

Définir (dans un Enum ou une constante) :

```php
const STATES_REALIZED   = ['TO_APPROVE','APPROVED','READY_FOR_LIVE_CODING','IN_LIVE_CODING'];
const STATES_VALIDATED  = ['APPROVED']; // ajoute 'IN_LIVE_CODING' si validé live-coding via un flag
```

> Astuce : si tu as un booléen `is_live_coding_validated`, tu peux considérer une tâche **validée** si
> `etat ∈ STATES_VALIDATED` **ou** `(etat='IN_LIVE_CODING' && is_live_coding_validated=true)`.

## B. Poids

* Si `taches.poids` existe → **moyenne pondérée**.
* Sinon → poids = 1.

## C. Progression d’une Microcompétence (pour un apprenant & un projet)

* **Numérateur** = somme des **poids** des `RealisationTache` dont l’**état ∈ STATES\_REALIZED**.
* **Dénominateur** = somme des poids de **toutes** les tâches de la micro-compétence.
* `progression = round(100 * numérateur / max(1, dénominateur))`.

## D. Note d’une Microcompétence

* Prendre uniquement les tâches **comptabilisables** : `note != null` **et** `état ∈ STATES_VALIDATED` (ou règle live-coding ci-dessus).
* `note = somme(note_tache * poids) / somme(poids)` (nullable si aucun élément).

## E. État d’une Microcompétence (dérivé)

Proposition simple et robuste :

* `A_FAIRE` : progression = 0.
* `EN_COURS` : 0 < progression < 100.
* `A_VALIDER` : progression = 100 **mais** au moins une tâche non “validée”.
* `VALIDE` : progression = 100 **et** toutes les tâches comptabilisables sont “validées”.

> Même logique remonte ensuite pour UA et Chapitre, mais en **agrégeant** sur les **micro-compétences** (et pour Chapitre sur les UAs) :
>
> * **progression** = moyenne (pondérée si tu as des poids par micro-compétence/UA, sinon moyenne simple) des `progression_cache` enfants.
> * **note** = moyenne (pondérée) des `note_cache` **non nulles**.
> * **état** applique la même grille à partir des enfants (tous 0 → `A_FAIRE`, mix → `EN_COURS`, tous 100% et toutes validées → `VALIDE`, sinon `A_VALIDER`).

---

# Squelette technique (Laravel)

## 1) Observer sur RealisationTache

```php
class RealisationTacheObserver
{
    public function created(RealisationTache $rt)   { $this->fire($rt); }
    public function updated(RealisationTache $rt)   { 
        if ($rt->wasChanged(['etat_realisation_tache_id','note','is_live_coding_validated'])) {
            $this->fire($rt);
        }
    }
    public function deleted(RealisationTache $rt)   { $this->fire($rt); }

    private function fire(RealisationTache $rt): void
    {
        event(new TacheRealisationChanged(
            apprenantId: $rt->apprenant_id,
            projetId: $rt->affectation_projet_id,
            microcompetenceId: $rt->tache->microcompetence_id,
            uaId: $rt->tache->ua_id ?? null,
            chapitreId: $rt->tache->chapitre_id ?? null,
            tacheId: $rt->tache_id
        ));
    }
}
```

## 2) Événement + Listener (avec Job unique)

```php
class TacheRealisationChanged
{
    public function __construct(
        public int $apprenantId,
        public int $projetId,
        public int $microcompetenceId,
        public ?int $uaId,
        public ?int $chapitreId,
        public int $tacheId
    ) {}
}

class RecomputeAggregatesListener
{
    public function handle(TacheRealisationChanged $e): void
    {
        RecomputeAggregatesJob::dispatch($e)->delay(now()->addSeconds(2))->onQueue('default');
    }
}
```

```php
class RecomputeAggregatesJob implements ShouldQueue
{
    use InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(public TacheRealisationChanged $e) {}

    public function uniqueId(): string
    {
        $k = $this->e;
        return "agg:{$k->apprenantId}:{$k->projetId}:{$k->microcompetenceId}";
    }

    public function handle(AggregationService $svc): void
    {
        $e = $this->e;
        $svc->recomputeMicrocompetence($e->apprenantId, $e->projetId, $e->microcompetenceId);
        if ($e->uaId)       $svc->recomputeUa($e->apprenantId, $e->projetId, $e->uaId);
        if ($e->chapitreId) $svc->recomputeChapitre($e->apprenantId, $e->projetId, $e->chapitreId);
    }
}
```

## 3) Service d’agrégation (extraits)

```php
class AggregationService
{
    public function recomputeMicrocompetence(int $apprenantId, int $projetId, int $mcId): void
    {
        // Récupérer les tâches de la micro-compétence avec la réalisation de cet apprenant dans ce projet
        $taches = Tache::where('microcompetence_id', $mcId)
            ->select('id','poids')
            ->with(['realisationTaches' => fn($q)=>$q
                ->where('apprenant_id', $apprenantId)
                ->where('affectation_projet_id', $projetId)
            ])->get();

        $totPoids = max(1, $taches->sum(fn($t)=> (float)($t->poids ?? 1)));

        $numProg = 0.0; $numNote = 0.0; $denNote = 0.0; $allValidated = true; $anyStarted = false;

        foreach ($taches as $t) {
            $p = (float)($t->poids ?? 1);
            $rt = $t->realisationTaches->first(); // 1 réalisation par apprenant/tâche

            if ($rt) {
                $etat = $rt->etat?->code;
                $started = $etat && $etat !== 'TODO';
                $anyStarted = $anyStarted || $started;

                // progression
                if ($etat && in_array($etat, STATES_REALIZED, true)) {
                    $numProg += $p;
                }

                // note
                if (!is_null($rt->note) && ($etat && (in_array($etat, STATES_VALIDATED, true) || ($etat==='IN_LIVE_CODING' && $rt->is_live_coding_validated)))) {
                    $numNote += $rt->note * $p;
                    $denNote += $p;
                } else {
                    $allValidated = false;
                }
            } else {
                $allValidated = false;
            }
        }

        $progression = (int) round(100 * $numProg / $totPoids);
        $note = $denNote > 0 ? round($numNote / $denNote, 2) : null;

        // état agrégé
        $etat = match (true) {
            $progression === 0                  => 'A_FAIRE',
            $progression < 100                  => 'EN_COURS',
            $progression === 100 && !$allValidated => 'A_VALIDER',
            default                             => 'VALIDE',
        };

        DB::table('realisation_microcompetences')
            ->where(compact('apprenantId','projetId'))
            ->where('microcompetence_id', $mcId)
            ->update([
                'progression_cache' => $progression,
                'note_cache'        => $note,
                'etat_code'         => $etat,
                'updated_at'        => now(),
            ]);
    }

    public function recomputeUa(int $apprenantId, int $projetId, int $uaId): void
    {
        $rows = DB::table('realisation_microcompetences')
            ->where(compact('apprenantId','projetId'))
            ->where('ua_id', $uaId)
            ->select('progression_cache','note_cache','etat_code')
            ->get();

        if ($rows->isEmpty()) {
            $progression = 0; $note = null; $etat='A_FAIRE';
        } else {
            $progression = (int) round($rows->avg('progression_cache'));
            $notes = $rows->pluck('note_cache')->filter(fn($n)=>!is_null($n));
            $note = $notes->isNotEmpty() ? round($notes->avg(), 2) : null;

            $all0   = $rows->every(fn($r)=> (int)$r->progression_cache === 0);
            $all100 = $rows->every(fn($r)=> (int)$r->progression_cache === 100);
            $allVal = $rows->every(fn($r)=> $r->etat_code === 'VALIDE');

            $etat = $all0 ? 'A_FAIRE' : ($all100 ? ($allVal ? 'VALIDE' : 'A_VALIDER') : 'EN_COURS');
        }

        DB::table('realisation_uas')
            ->where(compact('apprenantId','projetId'))
            ->where('ua_id', $uaId)
            ->update([
                'progression_cache' => $progression,
                'note_cache'        => $note,
                'etat_code'         => $etat,
                'updated_at'        => now(),
            ]);
    }

    public function recomputeChapitre(int $apprenantId, int $projetId, int $chapitreId): void
    {
        // Même logique que UA, mais en agrégeant sur realisation_uas du chapitre
        // ...
    }
}
```

---

# Migrations à prévoir (si manquants)

```php
Schema::table('realisation_microcompetences', function(Blueprint $t){
  $t->unsignedTinyInteger('progression_cache')->default(0);
  $t->decimal('note_cache',5,2)->nullable();
  $t->string('etat_code', 40)->default('A_FAIRE');
  $t->timestamp('last_computed_at')->nullable();
});

Schema::table('realisation_uas', function(Blueprint $t){
  $t->unsignedTinyInteger('progression_cache')->default(0);
  $t->decimal('note_cache',5,2)->nullable();
  $t->string('etat_code', 40)->default('A_FAIRE');
  $t->timestamp('last_computed_at')->nullable();
});

Schema::table('realisation_chapitres', function(Blueprint $t){
  $t->unsignedTinyInteger('progression_cache')->default(0);
  $t->decimal('note_cache',5,2)->nullable();
  $t->string('etat_code', 40)->default('A_FAIRE');
  $t->timestamp('last_computed_at')->nullable();
});
```

---

# Bonnes pratiques & détails qui comptent

* **Atomicité raisonnable** : chaque niveau (MC, UA, Chapitre) est mis à jour dans une transaction courte, mais on ne verrouille pas toute la hiérarchie. Cohérence **éventuelle** en quelques secondes.
* **Idempotence** : les jobs d’agrégation doivent pouvoir être relancés sans effets de bord (pas d’insert répétés, juste des `update`).
* **Tests** (à écrire) :

  * ∅ tâches → progression 0, note null, état `A_FAIRE`.
  * Tâches partiellement réalisées → `EN_COURS`.
  * 100% réalisées mais non toutes validées → `A_VALIDER`.
  * Tout validé + notes présentes → `VALIDE` et note agrégée correcte (pondérée si applicable).
  * Cas `is_live_coding_validated`.
* **Affichage** : respecter ta règle “ne pas afficher *moyenne* si la note n’existe pas” → si `note_cache === null`, masquer.

