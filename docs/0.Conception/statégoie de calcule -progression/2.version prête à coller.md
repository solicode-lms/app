Super — voici la **version prête à coller** (adaptable à tes namespaces). J’ai choisi des emplacements cohérents avec ce que tu utilises déjà (modules `Core`, `PkgCreationTache`, `PkgRealisationTache`). Ajuste les namespaces si besoin.

# 1) Règles d’état (codes réutilisables)

```php
<?php
// Modules/Core/Enums/EtatTacheCodes.php
namespace Modules\Core\Enums;

final class EtatTacheCodes
{
    public const TODO                   = 'TODO';
    public const IN_PROGRESS            = 'IN_PROGRESS';
    public const READY_FOR_LIVE_CODING  = 'READY_FOR_LIVE_CODING';
    public const IN_LIVE_CODING         = 'IN_LIVE_CODING';
    public const TO_APPROVE             = 'TO_APPROVE';
    public const APPROVED               = 'APPROVED';

    // Agrégation
    public const AGG_A_FAIRE  = 'A_FAIRE';
    public const AGG_EN_COURS = 'EN_COURS';
    public const AGG_A_VALIDER= 'A_VALIDER';
    public const AGG_VALIDE   = 'VALIDE';

    public const STATES_REALIZED = [
        self::TO_APPROVE, self::APPROVED, self::READY_FOR_LIVE_CODING, self::IN_LIVE_CODING
    ];

    public const STATES_VALIDATED = [
        self::APPROVED
    ];
}
```

# 2) Event, Listener, Job (unique + debounce)

```php
<?php
// Modules/Core/Events/TacheRealisationChanged.php
namespace Modules\Core\Events;

class TacheRealisationChanged
{
    public function __construct(
        public int $apprenantId,
        public int $projetId,
        public int $microcompetenceId,
        public ?int $uaId,
        public ?int $chapitreId
    ) {}
}
```

```php
<?php
// Modules/Core/Listeners/RecomputeAggregatesListener.php
namespace Modules\Core\Listeners;

use Modules\Core\Events\TacheRealisationChanged;
use Modules\Core\Jobs\RecomputeAggregatesJob;

class RecomputeAggregatesListener
{
    public function handle(TacheRealisationChanged $e): void
    {
        RecomputeAggregatesJob::dispatch($e)
            ->delay(now()->addSeconds(2)) // coalescing léger
            ->onQueue('default');
    }
}
```

```php
<?php
// Modules/Core/Jobs/RecomputeAggregatesJob.php
namespace Modules\Core\Jobs;

use Illuminate\Bus\Queueable;
use Illuminate\Queue\{SerializesModels, InteractsWithQueue};
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Contracts\Queue\ShouldBeUnique;
use Modules\Core\Events\TacheRealisationChanged;
use Modules\Core\Services\Progression\AggregationService;

class RecomputeAggregatesJob implements ShouldQueue, ShouldBeUnique
{
    use InteractsWithQueue, Queueable, SerializesModels;

    public function __construct(public TacheRealisationChanged $event) {}

    public function uniqueId(): string
    {
        $e = $this->event;
        return "agg:{$e->apprenantId}:{$e->projetId}:{$e->microcompetenceId}";
    }

    // Optionnel: limite la re-queue si bloqué
    public int $uniqueFor = 30; // secondes

    public function handle(AggregationService $svc): void
    {
        $e = $this->event;
        $svc->recomputeMicrocompetence($e->apprenantId, $e->projetId, $e->microcompetenceId);
        if ($e->uaId)       $svc->recomputeUa($e->apprenantId, $e->projetId, $e->uaId);
        if ($e->chapitreId) $svc->recomputeChapitre($e->apprenantId, $e->projetId, $e->chapitreId);
    }
}
```

# 3) Service d’agrégation (idempotent + lock)

```php
<?php
// Modules/Core/Services/Progression/AggregationService.php
namespace Modules\Core\Services\Progression;

use Illuminate\Support\Facades\{Cache, DB};
use Modules\Core\Enums\EtatTacheCodes as C;
use Modules\PkgCreationTache\Models\Tache;

class AggregationService
{
    public function recomputeMicrocompetence(int $apprenantId, int $projetId, int $mcId): void
    {
        $lockKey = "lock:mc:$apprenantId:$projetId:$mcId";
        $lock = Cache::lock($lockKey, 10);

        if (! $lock->get()) return;
        try {
            $taches = Tache::where('microcompetence_id', $mcId)
                ->select('id','poids','ua_id','chapitre_id')
                ->with(['realisationTaches' => fn($q)=>$q
                    ->where('apprenant_id', $apprenantId)
                    ->where('affectation_projet_id', $projetId)
                    ->with(['etat:id,code'])
                ])->get();

            $totPoids = max(1.0, (float) $taches->sum(fn($t)=> (float)($t->poids ?? 1)));

            $numProg = 0.0; $numNote = 0.0; $denNote = 0.0; $allValidated = true;
            foreach ($taches as $t) {
                $p  = (float)($t->poids ?? 1);
                $rt = $t->realisationTaches->first();
                if (! $rt) { $allValidated = false; continue; }

                $etat = $rt->etat?->code;
                if ($etat && in_array($etat, C::STATES_REALIZED, true)) {
                    $numProg += $p;
                }

                $valid = $etat && (in_array($etat, C::STATES_VALIDATED, true) ||
                                   ($etat === C::IN_LIVE_CODING && (bool)($rt->is_live_coding_validated ?? false)));

                if (!is_null($rt->note) && $valid) { $numNote += $rt->note * $p; $denNote += $p; }
                if (! $valid) { $allValidated = false; }
            }

            $progression = (int) round(100 * $numProg / $totPoids);
            $note = $denNote > 0 ? round($numNote / $denNote, 2) : null;
            $etat = match (true) {
                $progression === 0                     => C::AGG_A_FAIRE,
                $progression < 100                     => C::AGG_EN_COURS,
                $progression === 100 && !$allValidated => C::AGG_A_VALIDER,
                default                                => C::AGG_VALIDE,
            };

            DB::table('realisation_microcompetences')
                ->updateOrInsert(
                    ['apprenant_id'=>$apprenantId,'affectation_projet_id'=>$projetId,'microcompetence_id'=>$mcId],
                    ['progression_cache'=>$progression,'note_cache'=>$note,'etat_code'=>$etat,'updated_at'=>now()]
                );
        } finally {
            optional($lock)->release();
        }
    }

    public function recomputeUa(int $apprenantId, int $projetId, int $uaId): void
    {
        $rows = DB::table('realisation_microcompetences')
            ->where(['apprenant_id'=>$apprenantId,'affectation_projet_id'=>$projetId,'ua_id'=>$uaId])
            ->select('progression_cache','note_cache','etat_code')
            ->get();

        [$progression, $note, $etat] = $this->aggregateRows($rows);
        DB::table('realisation_uas')
            ->updateOrInsert(
                ['apprenant_id'=>$apprenantId,'affectation_projet_id'=>$projetId,'ua_id'=>$uaId],
                ['progression_cache'=>$progression,'note_cache'=>$note,'etat_code'=>$etat,'updated_at'=>now()]
            );
    }

    public function recomputeChapitre(int $apprenantId, int $projetId, int $chapitreId): void
    {
        $rows = DB::table('realisation_uas')
            ->where(['apprenant_id'=>$apprenantId,'affectation_projet_id'=>$projetId,'chapitre_id'=>$chapitreId])
            ->select('progression_cache','note_cache','etat_code')
            ->get();

        [$progression, $note, $etat] = $this->aggregateRows($rows);
        DB::table('realisation_chapitres')
            ->updateOrInsert(
                ['apprenant_id'=>$apprenantId,'affectation_projet_id'=>$projetId,'chapitre_id'=>$chapitreId],
                ['progression_cache'=>$progression,'note_cache'=>$note,'etat_code'=>$etat,'updated_at'=>now()]
            );
    }

    /** @return array{int, float|null, string} */
    private function aggregateRows($rows): array
    {
        if ($rows->isEmpty())
            return [0, null, C::AGG_A_FAIRE];

        $progression = (int) round($rows->avg('progression_cache'));
        $notes = $rows->pluck('note_cache')->filter(fn($n)=>!is_null($n));
        $note  = $notes->isNotEmpty() ? round($notes->avg(), 2) : null;

        $all0   = $rows->every(fn($r)=>(int)$r->progression_cache === 0);
        $all100 = $rows->every(fn($r)=>(int)$r->progression_cache === 100);
        $allVal = $rows->every(fn($r)=>$r->etat_code === C::AGG_VALIDE);

        $etat = $all0 ? C::AGG_A_FAIRE : ($all100 ? ($allVal ? C::AGG_VALIDE : C::AGG_A_VALIDER) : C::AGG_EN_COURS);
        return [$progression, $note, $etat];
    }
}
```

# 4) Observer sur RealisationTache

```php
<?php
// Modules/PkgRealisationTache/Observers/RealisationTacheObserver.php
namespace Modules\PkgRealisationTache\Observers;

use Modules\PkgRealisationTache\Models\RealisationTache;
use Modules\Core\Events\TacheRealisationChanged;

class RealisationTacheObserver
{
    public function created(RealisationTache $rt) { $this->fire($rt); }
    public function updated(RealisationTache $rt)
    {
        if ($rt->wasChanged(['etat_realisation_tache_id','note','is_live_coding_validated'])) {
            $this->fire($rt);
        }
    }
    public function deleted(RealisationTache $rt) { $this->fire($rt); }

    private function fire(RealisationTache $rt): void
    {
        $t = $rt->tache; // relation belongsTo Tache
        event(new TacheRealisationChanged(
            apprenantId: $rt->apprenant_id,
            projetId: $rt->affectation_projet_id,
            microcompetenceId: (int)$t->microcompetence_id,
            uaId: $t->ua_id ?? null,
            chapitreId: $t->chapitre_id ?? null
        ));
    }
}
```

# 5) Enregistrement (ServiceProviders)

**a.** Lier l’Observer (dans le provider du module `PkgRealisationTache`):

```php
// Modules/PkgRealisationTache/App/Providers/PkgRealisationTacheServiceProvider.php
use Modules\PkgRealisationTache\Models\RealisationTache;
use Modules\PkgRealisationTache\Observers\RealisationTacheObserver;

public function boot()
{
    // ... tes chargements habituels
    RealisationTache::observe(RealisationTacheObserver::class);
}
```

**b.** Mapper Event → Listener (dans un EventServiceProvider central, p.ex. `Modules/Core/App/Providers/EventServiceProvider.php`):

```php
protected $listen = [
    \Modules\Core\Events\TacheRealisationChanged::class => [
        \Modules\Core\Listeners\RecomputeAggregatesListener::class,
    ],
];
```

# 6) Colonnes “cache” (si manquantes)

```php
Schema::table('realisation_microcompetences', function(Blueprint $t){
    if (!Schema::hasColumn('realisation_microcompetences','progression_cache')) $t->unsignedTinyInteger('progression_cache')->default(0);
    if (!Schema::hasColumn('realisation_microcompetences','note_cache'))        $t->decimal('note_cache',5,2)->nullable();
    if (!Schema::hasColumn('realisation_microcompetences','etat_code'))         $t->string('etat_code',40)->default('A_FAIRE');
});

Schema::table('realisation_uas', function(Blueprint $t){
    if (!Schema::hasColumn('realisation_uas','progression_cache')) $t->unsignedTinyInteger('progression_cache')->default(0);
    if (!Schema::hasColumn('realisation_uas','note_cache'))        $t->decimal('note_cache',5,2)->nullable();
    if (!Schema::hasColumn('realisation_uas','etat_code'))         $t->string('etat_code',40)->default('A_FAIRE');
});

Schema::table('realisation_chapitres', function(Blueprint $t){
    if (!Schema::hasColumn('realisation_chapitres','progression_cache')) $t->unsignedTinyInteger('progression_cache')->default(0);
    if (!Schema::hasColumn('realisation_chapitres','note_cache'))        $t->decimal('note_cache',5,2)->nullable();
    if (!Schema::hasColumn('realisation_chapitres','etat_code'))         $t->string('etat_code',40)->default('A_FAIRE');
});
```

# 7) Points d’attention

* **QUEUE\_CONNECTION** ≠ `sync` (utilise `database` ou `redis`), et tu lances `queue:work`.
* **Idempotent** : tout passe par `updateOrInsert` et des recalculs purs.
* **Perf** : coalescing (2s), job unique, lock de 10s par micro-compétence.
* **Affichage** : si `note_cache === null`, tu n’affiches pas “moyenne”.

