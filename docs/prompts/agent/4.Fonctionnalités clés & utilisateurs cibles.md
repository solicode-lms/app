#### 4. Fonctionnalités clés & utilisateurs cibles

**Modules fonctionnels**

L’application **Sollms** est structurée autour de plusieurs modules fonctionnels spécialisés :

* Le module **PkgAutorisation** permet de gérer les utilisateurs, les rôles, les permissions et les affectations de profils.
* Le module **PkgFormation** prend en charge l’organisation des parcours pédagogiques : filières, modules, formateurs, spécialités et années de formation.
* Le module **PkgApprenants** gère les apprenants, leurs groupes, leurs origines (villes, nationalités), ainsi que leur rattachement aux groupes pédagogiques.
* Le module **PkgCompetences** permet de définir et d’évaluer les compétences, en lien avec les technologies, niveaux de difficulté et appréciations.
* Le module **PkgCreationProjet** sert à créer des projets pédagogiques incluant des livrables, des ressources, et des objectifs de transfert de compétence.
* Le module **PkgRealisationProjets** assure le suivi opérationnel des projets en cours, avec les affectations, les états de réalisation et les validations.
* Le module **PkgGestionTaches** est dédié à la gestion des tâches : assignation, priorisation, suivi, commentaires, et validation via workflows.
* Le module **PkgValidationProjets** permet aux évaluateurs externes d’intervenir pour valider des tâches ou des projets selon des critères définis.
* Le module **PkgAutoformation** propose des parcours individualisés avec des chapitres, des formations et un suivi d’état autonome.
* Le module **PkgWidgets** gère les tableaux de bord personnalisables via des widgets filtrés dynamiquement selon le rôle connecté.
* Le module **PkgNotification** centralise l’envoi des alertes, rappels et messages système liés à l’activité des utilisateurs.
* Le module **PkgGapp** fournit l’infrastructure pour définir des métadonnées dynamiques, des modèles configurables et des champs enrichis.
* Le module **Core** regroupe les composants transversaux : couleurs, modules système, filtres utilisateurs, contrôleurs, etc.

Des dépendances logiques existent entre les modules. Par exemple :

* Les tâches (PkgGestionTaches) sont rattachées à des projets (PkgRealisationProjets) qui sont eux-mêmes affectés à des formateurs (PkgFormation).
* Les compétences (PkgCompetences) sont validées à travers les projets, les tâches et les formations.
* Les widgets (PkgWidgets) et notifications (PkgNotification) s'appuient sur les données issues des autres modules pour une expérience utilisateur contextualisée.

---

**Rôles et droits des utilisateurs**

L'application prend en charge plusieurs profils utilisateurs avec des permissions différenciées :

* **Administrateur** :
  Dispose d’un accès global à tous les modules et fonctionnalités. Il est responsable de la configuration du système, de la gestion des utilisateurs, des rôles et de la structure des projets.

* **Formateur** :
  Gère les projets et les tâches qui lui sont affectés. Il peut créer des contenus, suivre les apprenants, évaluer leurs productions et valider leurs compétences.

* **Apprenant** :
  Accède uniquement aux tâches et formations qui lui sont assignées. Il peut soumettre des livrables, consulter son état d’avancement et recevoir les retours de ses formateurs.

L’interface utilisateur s’adapte dynamiquement selon le rôle :

* Les filtres affichés, les actions disponibles (édition, validation, suppression), ainsi que les boutons ou composants visibles varient en fonction des droits de l’utilisateur connecté.
* Cette adaptation permet une navigation ciblée, intuitive et sécurisée pour chaque profil.


### 📁 Structure standard d’un module SoliLMS

```
modules/
└── NomDuModule/                        # Exemple : PkgValidationProjets
    ├── Config/
    │   └── config.php                  # Configuration propre au module
    │
    ├── Database/
    │   ├── Migrations/                # Fichiers de migration des tables
    │   │   └── 2024_12_01_000000_create_xxx_table.php
    │   ├── Seeders/                   # Remplissage initial des données
    │   └── Factories/                 # Factories pour tests (facultatif)
    │
    ├── Entities/                      # Alias possible pour Models
    │   └── NomModel.php
    │
    ├── Http/
    │   ├── Controllers/
    │   │   └── Web/                   # Contrôleurs pour interface web
    │   │   └── Api/                   # Contrôleurs API (optionnel)
    │   ├── Requests/                  # FormRequests pour validation
    │   └── Middleware/                # Middleware spécifique (rare)
    │
    ├── Models/                        # Modèles Eloquent (peut remplacer Entities/)
    │   └── NomModel.php
    │
    ├── Providers/
    │   └── ModuleServiceProvider.php  # Enregistrement des routes, vues, etc.
    │
    ├── Resources/
    │   ├── views/                     # Vues Blade spécifiques au module
    │   │   ├── index.blade.php
    │   │   └── form.blade.php
    │   └── lang/
    │       └── fr/
    │           └── messages.php       # Traductions locales (optionnel)
    │
    ├── Routes/
    │   ├── web.php                    # Routes web (CRUD, interfaces)
    │   └── api.php                    # Routes API (si besoin)
    │
    ├── Services/
    │   ├── Base/                      # Services partagés (héritage)
    │   └── NomModelService.php        # Service métier principal du module
    │
    ├── Traits/                        # Fonctions réutilisables
    │   └── TraitX.php
    │
    ├── Tests/
    │   ├── Feature/                   # Tests d’intégration
    │   └── Unit/                      # Tests unitaires
    │
    └── module.json                    # Métadonnées : nom, alias, fournisseur, version
```

---

### 📌 Notes spécifiques à SoliLMS

* Les **services métiers** sont essentiels dans chaque module (`Services/NomModelService.php`) et héritent souvent de `BaseService`, `BaseFormateurService`, etc.
* Le fichier `module.json` permet de déclarer le module (nom, provider, dépendances) pour le chargement dynamique par Laravel.
* Les **routes** sont souvent **centralisées** dans `Routes/web.php` et chargées automatiquement via le `ServiceProvider`.
* Les **métadonnées Gapp** sont utilisées pour enrichir dynamiquement les champs, comportements de formulaire, ou affichages dans les vues.

