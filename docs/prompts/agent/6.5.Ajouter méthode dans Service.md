
#### ✅ Ajouter une méthode dans la classe Service

### 🎯 Objectif  
Créer une nouvelle méthode métier dans une classe `Service` tout en respectant la logique déjà existante pour garantir **cohérence**, **réutilisabilité** et **maintenabilité**.



### La **classe `Service`** dans le projet Solicode-LMS joue un rôle de **service métier**, centralisant la logique fonctionnelle liée aux entités du domaine. Elle est souvent utilisée comme intermédiaire entre les contrôleurs et les modèles, permettant de garder les contrôleurs légers et les traitements organisés.

---

### 🎯 **Structure Générale de la classe `Service`**

Dans ce projet, les services suivent une architecture orientée **héritage** pour centraliser les comportements réutilisables :

#### 1. **BaseService** (Classe mère)
- Localisation : `BaseService.php`
- Contient les méthodes génériques :
  - `getModelClass()` : Retourne la classe du modèle.
  - `query()` : Fournit un builder de requête pour le modèle.
  - `findOrFail($id)` : Trouve un enregistrement ou lève une exception.
  - `create($data)` / `update($model, $data)` / `delete($model)` : Méthodes CRUD de base.
  - `getByReference($ref)` : Récupération d'un enregistrement par référence.
  - Gestion des transactions avec `DB::transaction`.

#### 2. **BaseFormateurService** (Classe intermédiaire)
- Spécifique aux modèles liés à un `formateur`.
- Étend `BaseService`.
- Ajoute des méthodes comme :
  - `getFormateurQuery($formateurId)`
  - `getByReferenceAndFormateurId(...)`
  - `createWithFormateurId(...)`

#### 3. **FormateurService** (Exemple concret)
- Étend `BaseFormateurService`.
- Applique la logique spécifique au modèle `Formateur`.

---

### 📦 **Exemple simplifié**

```php
// Exemple de service métier pour gérer les "Tâches"
namespace App\Services;

use App\Models\Tache;
use Illuminate\Support\Facades\DB;

class TacheService extends BaseFormateurService
{
    protected function getModelClass(): string
    {
        return Tache::class;
    }

    public function validerTache(int $id, array $data)
    {
        return DB::transaction(function () use ($id, $data) {
            $tache = $this->findOrFail($id);
            $tache->etat = 'validée';
            $tache->save();
            return $tache;
        });
    }
}
```

---

### ✅ **Avantages de cette architecture**

- **Réutilisabilité** : les traitements de base sont centralisés.
- **Clarté** : la logique métier est séparée des contrôleurs.
- **Testabilité** : facilite les tests unitaires des services.
- **Extensibilité** : possibilité d'ajouter des comportements sans toucher au cœur.

Souhaites-tu que je génère une **metadata Gapp** associée à une opération typique de ce service (comme `createWithFormateurId`, `getByReference`, etc.) ?


### 🧱 Règles à suivre

1. **Réutilisation prioritaire des méthodes existantes**
   - Utiliser en priorité les méthodes CRUD fournies par le `CrudTrait` :
     - `all()`, `find()`, `create()`, `update()`, `destroy()`, `edit()`, `updateOnlyExistanteAttribute()`, `updateOrCreate()`, `getByReference()`, `createInstance()`
   - Utiliser les méthodes utilitaires :
     - `hasOrdreColumn()`, `getNextOrdre()`, `reorderOrdreColumn()`
   - Lors de l’utilisation d'entités secondaires (ex. : `RealisationTache`), **toujours passer par leur propre service dédié** (ex. : `RealisationTacheService`) au lieu d’un appel direct au modèle.

2. **Créer une méthode uniquement si elle est spécifique au métier**
   - Exemple : `getEtatInitialByFormateur()`, `synchroniserTachesDuProjet($projetId)`
   - La méthode doit encapsuler un **traitement fonctionnel clair**.

3. **Utiliser les outils fournis par la classe `Service`**
   - `$this->model` pour manipuler l'entité principale
   - `$this->viewState`, `$this->sessionState` pour le contexte utilisateur
   - Injecter ou instancier les services secondaires de manière explicite :
     ```php
     $realisationTacheService = new RealisationTacheService();
     $realisationTacheService->create([...]);
     ```

4. **Encapsuler les traitements complexes**
   - Si la logique comporte plusieurs étapes (ex. création d’un projet et ses tâches), la diviser en **méthodes privées**, ou bien utiliser des services métiers complémentaires.

---

### 🧰 Liste des méthodes disponibles

#### 📦 Méthodes CRUD (`CrudTrait`)

- `all()`
- `find(int $id)`
- `create(array|Model $data)`
- `update($id, array $data)`
- `destroy($id)`
- `edit($id)`
- `updateOnlyExistanteAttribute($id, array $data)`
- `updateOrCreate(array $attributes, array $values)`
- `getByReference(string $reference)`
- `createInstance(array $data = [])`

#### ⚙️ Méthodes utilitaires internes

- `hasOrdreColumn()`
- `getNextOrdre()`
- `reorderOrdreColumn(?int $ancienOrdre, int $nouvelOrdre, int $idEnCours = null)`

---

### 💡 Exemples de méthodes métier valides

- `getTachesByProjetId(int $projetId)`
- `synchroniserRealisationTaches(int $realisationProjetId)` → via `RealisationTacheService`
- `getDefaultEtatByFormateurId(int $formateurId)`
- `dupliquerAvecRelations(int $idOriginal)`

