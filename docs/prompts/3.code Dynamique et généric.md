## ğŸ§  Objectif : CrÃ©ation dâ€™un Code Dynamique et GÃ©nÃ©rique

Dans le cadre du projet Solicode-LMS, il est essentiel que les classes **Controller** et **Service** soient **les plus dynamiques et gÃ©nÃ©riques possible**, afin de garantir **la rÃ©utilisabilitÃ©**, **la maintenabilitÃ©** et **lâ€™adaptabilitÃ©** du code Ã  diffÃ©rents modÃ¨les (entities) sans duplication.

---

## ğŸ” DÃ©finition : Code Dynamique

Un **code dynamique** est un code qui sâ€™adapte **automatiquement au contexte ou Ã  la configuration** sans dÃ©pendre de noms codÃ©s en dur (comme des noms de modÃ¨les, de contrÃ´leurs ou de permissions).

Cela peut Ãªtre rÃ©alisÃ© par :
- Lâ€™utilisation de **reflection** (ex. : `get_class`, `Str::snake`, `Str::kebab`, etc.).
- Lâ€™accÃ¨s Ã  des **informations de contexte** via des variables ou des conventions.
- Lâ€™injection de **dÃ©pendances dynamiques** (services, modÃ¨les, permissions).
- Lâ€™usage de **traits ou classes de base** pour partager une logique adaptable.

---

## ğŸ”„ DÃ©finition : Code GÃ©nÃ©rique

Un **code gÃ©nÃ©rique** est un code rÃ©utilisable pour **plusieurs entitÃ©s ou cas dâ€™usage** sans modification directe. Il repose sur :
- Une **architecture orientÃ©e abstraction** (`BaseService`, `BaseController`, etc.).
- Des **paramÃ¨tres ou mÃ©tadatas configurables** (modÃ¨le Ã  utiliser, rÃ¨gles de validation...).
- La sÃ©paration claire entre **logique mÃ©tier spÃ©cifique** et **logique commune**.

---

## ğŸš« Exemple de Code Non GÃ©nÃ©rique & Non Dynamique

Voici un exemple typique de code non gÃ©nÃ©rique :

```php
public function updateAttributes(Request $request)
{
    if (!auth()->user()->can('update-widgetUtilisateur')) {
        abort(403, 'Permission refusÃ©e : update-widgetUtilisateur');
    }

    $validated = $request->validate([
        'id' => 'required|integer|exists:widget_utilisateurs,id',
        'ordre' => 'nullable|integer|min:1',
        'visible' => 'nullable|boolean',
    ]);

    $dataToUpdate = [];

    if (array_key_exists('ordre', $validated)) {
        $dataToUpdate['ordre'] = $validated['ordre'];
    }

    if (array_key_exists('visible', $validated)) {
        $dataToUpdate['visible'] = $validated['visible'];
    }

    if (empty($dataToUpdate)) {
        return JsonResponseHelper::error('Aucune donnÃ©e Ã  mettre Ã  jour.', 422);
    }

    $this->widgetUtilisateurService->update($validated['id'], $dataToUpdate);

    return JsonResponseHelper::success(
        __('Mise Ã  jour rÃ©ussie.'),
        ['entity_id' => $validated['id']]
    );
}
```

### âŒ ProblÃ¨mes :
- La permission est codÃ©e en dur : `'update-widgetUtilisateur'`
- Le nom du modÃ¨le est fixÃ© (`widget_utilisateurs`)
- Le nom du service est spÃ©cifique (`widgetUtilisateurService`)
- La logique est **non factorisable** dans un contrÃ´leur gÃ©nÃ©rique

---

## âœ… Exemple de Code GÃ©nÃ©rique et Dynamique

```php
public function updateAttributes(Request $request)
{
    $modelName = $this->getModelName(); // Ex: "WidgetUtilisateur"
    $service = $this->getService(); // RÃ©solu dynamiquement

    $this->authorizeAction('update', $modelName);

    $validated = $request->validate([
        'id' => 'required|integer|exists:' . Str::snake(Str::plural($modelName)) . ',id',
        'ordre' => 'nullable|integer|min:1',
        'visible' => 'nullable|boolean',
    ]);

    $dataToUpdate = collect($validated)->only(['ordre', 'visible'])->toArray();

    if (empty($dataToUpdate)) {
        return JsonResponseHelper::error('Aucune donnÃ©e Ã  mettre Ã  jour.', 422);
    }

    $service->update($validated['id'], $dataToUpdate);

    return JsonResponseHelper::success(__('Mise Ã  jour rÃ©ussie.'), ['entity_id' => $validated['id']]);
}
```

> ğŸ’¡ **Fonctions utilitaires** comme `getModelName()`, `getService()` et `authorizeAction()` peuvent Ãªtre dÃ©finies dans un **BaseController**.
