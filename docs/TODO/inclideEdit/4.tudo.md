# 0) Ce qu‚Äôon va ajouter

* **API** JSON :

  * `GET fieldMeta` : renvoie le *type d‚Äô√©diteur*, les *options*, la *validation*, l‚Äô`etag`.
  * `PATCH partiel` : met √† jour un seul champ avec **If-Match** (concurrence optimiste) et renvoie la *valeur affichable*.

* **Front** :

  * `FieldRegistry` (√©diteurs r√©utilisables : text, select, date, bool).
  * `MetaCache` (cache des metas par champ).
  * `CellOrchestrator` (ouvre l‚Äô√©diteur au double-clic, g√®re Enter/Esc/Tab, fait le PATCH).
  * `Prefetcher` (pr√©charge metas des lignes visibles).

D√©ploiement **progressif** avec un flag, sans casser l‚Äôexistant.

---

# 1) Routes API (backend Laravel)

Ajoute des routes JSON sous le m√™me pr√©fixe module (auth web OK si tu utilises AJAX avec le cookie CSRF).

```php
// modules/PkgRealisationTache/routes/api.inline.php
use Illuminate\Support\Facades\Route;
use Modules\PkgRealisationTache\Controllers\Inline\RealisationTacheInlineController;

Route::middleware(['auth'])->prefix('/admin/PkgRealisationTache/api')->group(function () {
    // M√©tadonn√©es d‚Äôun champ (√©diteur, options, validation, etag‚Ä¶)
    Route::get('realisation-taches/{id}/field-meta', [RealisationTacheInlineController::class, 'fieldMeta'])
        ->name('realisationTaches.inline.fieldMeta');

    // PATCH partiel (un ou plusieurs champs)
    Route::patch('realisation-taches/{id}', [RealisationTacheInlineController::class, 'patch'])
        ->name('realisationTaches.inline.patch');
});
```

Inclure ce fichier dans ton `RouteServiceProvider` du module, ou `routes/web.php` si tu pr√©f√®res (garde `/api/` dans l‚ÄôURL pour clarifier).

---

# 2) Controller Inline

```php
<?php
// modules/PkgRealisationTache/Controllers/Inline/RealisationTacheInlineController.php

namespace Modules\PkgRealisationTache\Controllers\Inline;

use Illuminate\Http\Request;
use Modules\Core\Controllers\Base\AdminController;
use Modules\PkgRealisationTache\Services\RealisationTacheService;
use Modules\Core\App\Helpers\JsonResponseHelper;

class RealisationTacheInlineController extends AdminController
{
    public function __construct(private RealisationTacheService $service)
    {
        parent::__construct();
    }

    // GET /field-meta?field=etat_realisation_tache_id&context=...
    public function fieldMeta(Request $request, int $id)
    {
        $entity = $this->service->edit($id);
        $this->authorize('edit', $entity);

        $field = $request->query('field');
        abort_if(!$field, 422, 'Param√®tre field manquant.');

        // ‚úÖ ACL champ
        $updatable = $this->service->getFieldsEditable();
        abort_unless(in_array($field, $updatable), 403, 'Champ non √©ditable.');

        // ‚úÖ Construit la meta (type, options, validation, etag, schema)
        $context = $request->query(); // ex: scope formateur, etc.
        $meta = $this->service->buildFieldMeta($entity, $field, $context);

        return response()->json($meta);
    }

    // PATCH partiel avec If-Match (ETag)
    public function patch(Request $request, int $id)
    {
        $entity = $this->service->find($id);
        $this->authorize('update', $entity);

        $ifMatch = $request->header('If-Match');
        $currentEtag = $this->service->etag($entity);
        if (!$ifMatch || $ifMatch !== $currentEtag) {
            return response()->json(['error' => 'Conflict', 'message' => 'Donn√©es obsol√®tes.'], 409);
        }

        $changes = $request->input('changes', []);
        if (!is_array($changes) || empty($changes)) {
            return JsonResponseHelper::error('Aucun changement fourni.', null, 422);
        }

        // ‚úÖ Filtrer aux champs √©ditables + valider
        $updated = $this->service->applyInlinePatch($entity, $changes);

        // üîé Valeurs affichables (labels, badge, formats dates‚Ä¶)
        $display = $this->service->formatDisplayValues($updated, array_keys($changes));

        // Option: d√©clencher un job et renvoyer un token si traitement long
        $jobToken = $this->service->getCrudJobToken() ?: null;

        return response()->json([
            'ok'      => true,
            'entity_id' => $updated->id,
            'display' => $display,
            'etag'    => $this->service->etag($updated->fresh()),
            'job_token' => $jobToken,
        ]);
    }
}
```

---

# 3) Service : metas, validation, patch, display, etag

Ajoute ces m√©thodes (ou un `InlineService` d√©di√© si tu pr√©f√®res). Exemple minimal pour 4 champs courants.

```php
<?php
// modules/PkgRealisationTache/Services/RealisationTacheService.php (extraits)

namespace Modules\PkgRealisationTache\Services;

use Illuminate\Support\Arr;
use Illuminate\Support\Facades\Validator;
use Modules\PkgRealisationTache\Models\RealisationTache;
use Modules\PkgRealisationTache\Services\Base\BaseRealisationTacheService;

class RealisationTacheService extends BaseRealisationTacheService
{
    // Ex: ["libelle","etat_realisation_tache_id","date_echeance","is_live_coding", ...]
    public function getFieldsEditable(): array
    {
        return [
            'libelle',
            'etat_realisation_tache_id',
            'date_echeance',
            'is_live_coding',
            // ... compl√®te selon ton mod√®le
        ];
    }

    public function etag(RealisationTache $e): string
    {
        // ETag faible bas√© sur updated_at (simple & suffisant)
        $ver = optional($e->updated_at)->timestamp ?? 0;
        return 'W/"rt-'.$e->id.'-'.$ver.'"';
    }

    /**
     * Construit les metas d‚Äôun champ (type √©diteur, options, validation‚Ä¶)
     */
    public function buildFieldMeta(RealisationTache $e, string $field, array $context = []): array
    {
        $schemaVersion = 'v1';
        $meta = [
            'entity' => 'realisation_tache',
            'id'     => $e->id,
            'field'  => $field,
            'writable' => in_array($field, $this->getFieldsEditable()),
            'schema_version' => $schemaVersion,
            'etag' => $this->etag($e),
        ];

        // Types/validators simples par champ ‚Äî ajuste selon ton domaine
        switch ($field) {
            case 'libelle':
                $meta += [
                    'type' => 'text',
                    'validation' => ['string', 'min:2', 'max:255'],
                    'value' => $e->libelle,
                ];
                break;

            case 'etat_realisation_tache_id':
                $options = app(EtatRealisationTacheService::class)->getAllForSelect($e->etatRealisationTache);
                // format: [id => label]
                $values = collect($options)->map(fn($label, $id) => ['value' => (int)$id, 'label' => $label])->values();
                $meta += [
                    'type' => 'select',
                    'required' => true,
                    'options' => ['source' => 'static', 'values' => $values],
                    'validation' => ['integer', 'in:'.implode(',', array_keys($options))],
                    'value' => $e->etat_realisation_tache_id,
                    'display' => ['component' => 'badge'], // hint UI
                ];
                break;

            case 'date_echeance':
                $meta += [
                    'type' => 'date',
                    'validation' => ['date'],
                    'value' => optional($e->date_echeance)->format('Y-m-d'),
                ];
                break;

            case 'is_live_coding':
                $meta += [
                    'type' => 'boolean',
                    'validation' => ['boolean'],
                    'value' => (bool)$e->is_live_coding,
                ];
                break;

            default:
                abort(404, 'Meta inconnue pour ce champ.');
        }

        return $meta;
    }

    /**
     * Applique un PATCH partiel (validation par champ + r√®gles m√©tier).
     */
    public function applyInlinePatch(RealisationTache $e, array $changes): RealisationTache
    {
        $allowed = $this->getFieldsEditable();
        $filtered = Arr::only($changes, $allowed);
        if (empty($filtered)) {
            abort(422, 'Aucun champ autoris√©.');
        }

        // Construit dynamiquement les r√®gles √† partir de buildFieldMeta()
        $rules = [];
        $data  = [];
        foreach ($filtered as $field => $value) {
            $meta = $this->buildFieldMeta($e, $field);
            // transforme en r√®gles Laravel
            $laravelRules = array_map(function($r) {
                return is_string($r) ? $r : $this->ruleToString($r);
            }, $meta['validation'] ?? []);
            $rules[$field] = $laravelRules ?: ['nullable'];
            $data[$field]  = $value;
        }

        Validator::make($data, $rules)->validate();

        // R√®gles m√©tier (exemples)
        // - emp√™cher date pass√©e si √©tat = Valid√©e, etc.
        // $this->domainGuard($e, $data);

        $e->fill($data);
        $e->save();

        return $e;
    }

    private function ruleToString($rule): string
    {
        // simple normalisation si $rule est un array (peu utilis√© ici)
        return is_array($rule) ? implode('|', $rule) : (string)$rule;
    }

    /**
     * Retourne des valeurs "affichables" pour le rendu de cellule.
     * Ex: label d‚Äôun select, badge color, format date, etc.
     */
    public function formatDisplayValues(RealisationTache $e, array $fields): array
    {
        $out = [];
        foreach ($fields as $field) {
            switch ($field) {
                case 'libelle':
                    $out[$field] = ['text' => (string)$e->libelle];
                    break;

                case 'etat_realisation_tache_id':
                    $label = optional($e->etatRealisationTache)->libelle ?? '‚Äî';
                    $palette = [
                        'TODO'     => 'secondary',
                        'DOING'    => 'warning',
                        'APPROVED' => 'success',
                    ];
                    $code = optional($e->etatRealisationTache->workflowTache ?? null)->code;
                    $out[$field] = [
                        'text'  => $label,
                        'badge' => $palette[$code] ?? 'secondary',
                    ];
                    break;

                case 'date_echeance':
                    $out[$field] = ['text' => optional($e->date_echeance)->format('Y-m-d') ?? '‚Äî'];
                    break;

                case 'is_live_coding':
                    $out[$field] = ['text' => $e->is_live_coding ? 'Oui' : 'Non'];
                    break;

                default:
                    $out[$field] = ['text' => (string) data_get($e, $field, '‚Äî')];
            }
        }
        return $out;
    }
}
```

> Ajuste les champs/relations/labels selon ton data model.

---

# 4) Policy (ACL par champ)

Si tu veux affiner les droits champ par champ :

```php
// app/Policies/RealisationTachePolicy.php (extrait)
public function updateField(User $user, RealisationTache $e, string $field): bool
{
    // ex: seuls les formateurs peuvent toucher l‚Äô√©tat
    if ($field === 'etat_realisation_tache_id') {
        return $user->hasRole('formateur');
    }
    return $user->can('update realisation_tache'); // fallback
}
```

Et dans `buildFieldMeta()` / `applyInlinePatch()`, v√©rifie `updateField`.

---

# 5) Marquage HTML des cellules

Dans ta vue `index` (ou partial `_table.blade.php`), pour chaque cellule √©ditable :

```blade
<td class="rt-editable"
    role="gridcell"
    tabindex="0"
    data-entity="realisation_tache"
    data-id="{{ $rt->id }}"
    data-field="etat_realisation_tache_id"
>
  {{-- rendu initial (label/badge) --}}
  @include('PkgRealisationTache::partials._etat_badge', ['rt' => $rt])
</td>

<td class="rt-editable"
    role="gridcell"
    tabindex="0"
    data-entity="realisation_tache"
    data-id="{{ $rt->id }}"
    data-field="libelle"
>
  {{ $rt->libelle }}
</td>
```

---

# 6) Frontend ‚Äì modules (l√©ger, vanilla + jQuery possible)

## 6.1 FieldRegistry (√©diteurs)

```js
// resources/js/inline-v2/FieldRegistry.js
export class FieldRegistry {
  constructor() { this.map = new Map(); }
  register(type, factory) { this.map.set(type, factory); }
  create(type, props) {
    const factory = this.map.get(type);
    if (!factory) throw new Error('Editor not found: '+type);
    return factory(props);
  }
}
```

### √âditeurs de base

```js
// resources/js/inline-v2/editors.js
export const editors = {
  text: ({ meta, value, onCommit, onCancel }) => ({
    mount(container) {
      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'form-control form-control-sm';
      input.value = value ?? '';
      input.addEventListener('keydown', e => {
        if (e.key === 'Escape') onCancel();
        if (e.key === 'Enter') onCommit(input.value);
      });
      input.addEventListener('blur', () => onCommit(input.value));
      container.innerHTML = '';
      container.appendChild(input);
      input.focus();
      input.select();
    },
    destroy() {},
    focus() { container.querySelector('input')?.focus(); }
  }),

  boolean: ({ meta, value, onCommit, onCancel }) => ({
    mount(container) {
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!value;
      cb.addEventListener('keydown', e => { if (e.key==='Escape') onCancel(); });
      cb.addEventListener('change', () => onCommit(cb.checked ? 1 : 0));
      container.innerHTML = '';
      container.appendChild(cb);
      cb.focus();
    },
    destroy() {},
    focus() { container.querySelector('input')?.focus(); }
  }),

  date: ({ meta, value, onCommit, onCancel }) => ({
    mount(container) {
      const input = document.createElement('input');
      input.type = 'date';
      input.className = 'form-control form-control-sm';
      input.value = value || '';
      input.addEventListener('keydown', e => {
        if (e.key === 'Escape') onCancel();
        if (e.key === 'Enter') onCommit(input.value);
      });
      input.addEventListener('blur', () => onCommit(input.value));
      container.innerHTML = '';
      container.appendChild(input);
      input.focus();
    },
    destroy() {},
    focus() {}
  }),

  select: ({ meta, value, onCommit, onCancel }) => ({
    mount(container) {
      const select = document.createElement('select');
      select.className = 'form-control form-control-sm';
      (meta.options?.values || []).forEach(({value: v, label}) => {
        const opt = document.createElement('option');
        opt.value = String(v);
        opt.textContent = label;
        if (String(v) === String(value)) opt.selected = true;
        select.appendChild(opt);
      });
      select.addEventListener('keydown', e => { if (e.key==='Escape') onCancel(); if (e.key==='Enter') onCommit(select.value); });
      select.addEventListener('change', () => onCommit(select.value));
      container.innerHTML = '';
      container.appendChild(select);
      select.focus();
    },
    destroy() {},
    focus() {}
  }),
};
```

## 6.2 MetaCache + client API

```js
// resources/js/inline-v2/MetaCache.js
export class MetaCache {
  constructor({ ttlMs = 300000 }) { this.ttl = ttlMs; this.map = new Map(); }
  _k(entity, id, field, ctx='') { return `${entity}:${id}:${field}:${ctx}`; }
  get(entity, id, field, ctx='') {
    const e = this.map.get(this._k(entity,id,field,ctx));
    return e && (Date.now()-e.ts < this.ttl) ? e.meta : null;
  }
  set(entity, id, field, ctx, meta) {
    this.map.set(this._k(entity,id,field,ctx), { ts: Date.now(), meta });
  }
  invalidateEntity(entity, id) {
    for (const k of [...this.map.keys()]) if (k.startsWith(`${entity}:${id}:`)) this.map.delete(k);
  }
}

// resources/js/inline-v2/api.js
export const api = {
  async fetchMeta(baseUrl, id, field, ctxParams={}) {
    const url = new URL(`${baseUrl}/field-meta`);
    url.pathname = `${baseUrl}/field-meta`.replace(/\/$/, '');
    url.searchParams.set('field', field);
    Object.entries(ctxParams).forEach(([k,v]) => url.searchParams.set(k, v));
    return $.get(url.toString().replace('field-meta', `realisation-taches/${id}/field-meta`));
  },
  async patch(baseUrl, id, changes, etag) {
    return $.ajax({
      url: `${baseUrl}/realisation-taches/${id}`,
      method: 'PATCH',
      headers: { 'If-Match': etag, 'X-CSRF-TOKEN': $('meta[name="csrf-token"]').attr('content') },
      contentType: 'application/json',
      data: JSON.stringify({ changes })
    });
  }
};
```

## 6.3 Orchestrateur + Prefetch

```js
// resources/js/inline-v2/Orchestrator.js
import { FieldRegistry } from './FieldRegistry';
import { editors } from './editors';
import { MetaCache } from './MetaCache';
import { api } from './api';

export class Orchestrator {
  constructor({ tableSelector, cellSelector='.rt-editable', baseUrl='/admin/PkgRealisationTache/api', ctxParams={} }) {
    this.tableSelector = tableSelector;
    this.cellSelector  = cellSelector;
    this.baseUrl       = baseUrl;
    this.ctxParams     = ctxParams;
    this.cache = new MetaCache({});
    this.registry = new FieldRegistry();
    Object.entries(editors).forEach(([type, factory]) => this.registry.register(type, factory));
    this.active = null;
  }

  init() {
    const $table = $(this.tableSelector);
    $table.on('dblclick', this.cellSelector, e => this.open(e.currentTarget));
    $table.on('keydown', this.cellSelector, e => {
      if (e.key === 'Enter') { e.preventDefault(); this.open(e.currentTarget); }
    });

    // Prefetch metas des lignes visibles
    this.prefetchVisible();
  }

  async open(cellEl) {
    if (this.active) this.cancel();
    const $cell = $(cellEl);
    const entity = $cell.data('entity');
    const id     = $cell.data('id');
    const field  = $cell.data('field');

    // garde le contenu pour rollback
    $cell.data('original-html', $cell.html());
    this.active = $cell;

    try {
      let meta = this.cache.get(entity, id, field);
      if (!meta) {
        meta = await api.fetchMeta('/admin/PkgRealisationTache/api', id, field, this.ctxParams);
        this.cache.set(entity, id, field, '', meta);
      }

      const value = meta.value ?? null;
      const editor = this.registry.create(meta.type, {
        meta, value,
        onCommit: (val) => this.commit($cell, meta, val),
        onCancel: () => this.cancel()
      });
      editor.mount(cellEl);

    } catch (e) {
      this.cancel(true);
      toastr.error("Impossible d'ouvrir l‚Äô√©diteur.");
    }
  }

  async commit($cell, meta, newValue) {
    try {
      // Optimistic UI (visuel rapide)
      $cell.html(`<span class="text-muted">‚Ä¶</span>`);

      const res = await api.patch('/admin/PkgRealisationTache/api', meta.id, { [meta.field]: newValue }, meta.etag);

      const display = res.display?.[meta.field];
      const text = display?.text ?? String(newValue ?? '');
      // badge ? tu peux mapper c√¥t√© front aussi
      $cell.text(text);

      // mettre √† jour cache ETag
      meta.etag = res.etag;
      this.cache.set(meta.entity, meta.id, meta.field, '', meta);
      this.active = null;

      // Si job long, montre un spinner discret et laisse ton poller existant faire le refresh ligne
      if (res.job_token) {
        $cell.append(' <i class="fas fa-sync fa-spin" aria-label="Traitement..."></i>');
      }

    } catch (xhr) {
      if (xhr.status === 409) {
        // Conflit ‚Üí reload cellule: refetch meta + valeur
        this.cache.invalidateEntity(meta.entity, meta.id);
        toastr.warning("Cette ligne a √©t√© modifi√©e ailleurs. Actualisation‚Ä¶");
      } else if (xhr.responseJSON?.errors) {
        toastr.error(Object.values(xhr.responseJSON.errors).join('<br>'));
      } else {
        toastr.error("Erreur lors de l‚Äôenregistrement.");
      }
      this.rollback($cell);
    }
  }

  cancel(error = false) {
    if (!this.active) return;
    if (!error) this.rollback(this.active);
    this.active = null;
  }

  rollback($cell) {
    const orig = $cell.data('original-html');
    if (orig !== undefined) $cell.html(orig);
    $cell.removeData('original-html');
  }

  prefetchVisible() {
    const rows = document.querySelectorAll(`${this.tableSelector} tbody tr`);
    const io = new IntersectionObserver(entries => {
      for (const entry of entries) {
        if (!entry.isIntersecting) continue;
        const row = entry.target;
        $(row).find(this.cellSelector).each(async (_, cell) => {
          const $c = $(cell);
          const entity = $c.data('entity'), id = $c.data('id'), field = $c.data('field');
          if (!this.cache.get(entity, id, field)) {
            try { 
              const meta = await api.fetchMeta('/admin/PkgRealisationTache/api', id, field, this.ctxParams);
              this.cache.set(entity, id, field, '', meta);
            } catch {}
          }
        });
        io.unobserve(row);
      }
    }, { threshold: 0.1 });
    rows.forEach(r => io.observe(r));
  }
}
```

**Bootstrap c√¥t√© page index :**

```html
<script type="module">
  import { Orchestrator } from '/js/inline-v2/Orchestrator.js';

  const featureEnabled = true; // ou config('features.inline_edit_v2')
  if (featureEnabled) {
    const ctxParams = {}; // ex: ta viewState si n√©cessaire
    const orch = new Orchestrator({
      tableSelector: '#tableRealisationTache',
      cellSelector:  '.rt-editable',
      baseUrl: '/admin/PkgRealisationTache/api',
      ctxParams
    });
    orch.init();
  }
</script>
```

---

# 7) Strat√©gie de migration

1. **Activer sur 2 champs** d‚Äôabord (ex. `etat_realisation_tache_id`, `libelle`).
2. Laisser l‚Äôancien syst√®me en place, contr√¥l√© par un **flag** (`features.inline_edit_v2`).
3. Mesurer : latence moyenne (ouverture/commit), taux de 409, erreurs validation.
4. √âtendre aux autres champs + ajouter √©diteurs sp√©cifiques si besoin (tags, async-select).

---

# 8) Tests manuels (rapides)

* Double-clic ‚Üí √©diteur s‚Äôouvre < 150 ms (apr√®s 1er cache).
* Enter ‚Üí sauvegarde, affiche la valeur format√©e, pas de reload global.
* Esc ‚Üí rollback propre.
* Conflit : ouvrir la m√™me ligne dans deux onglets, modifier ‚Üí v√©rifier le **409** + message ‚ÄúActualiser‚Ä¶‚Äù.
* Champs interdits (ACL champ) ‚Üí 403.
* Validation (ex. min, in:‚Ä¶) ‚Üí erreurs propres (toast) et rollback.

---

# 9) Bonus (optionnel)

* **LocalStorage** pour persister le MetaCache (cl√© par `schema_version` + `contextHash`).
* **SSE** pour suivre `job_token` (tu as d√©j√† un poller ‚Üí branche-le).
* **Accessibilit√©** : `aria-live="polite"` quand la valeur change, focus management nickel.

---

Si tu veux, je peux te pr√©parer un **mini-PR** dans ton module avec :

* le contr√¥leur `InlineController`,
* les m√©thodes `buildFieldMeta / applyInlinePatch / formatDisplayValues / etag`,
* la vue index annot√©e (`.rt-editable`),
* et les fichiers JS pr√™ts √† builder.
